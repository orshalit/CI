################################################################################
# CI/CD Pipeline - Production Grade
# 
# This workflow provides comprehensive CI/CD including:
# - Code quality checks (linting, formatting)
# - Security scanning
# - Unit and integration testing
# - Test coverage reporting
# - Docker image building with versioning
# - Multi-environment deployment
# - Artifact publishing
################################################################################

name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    tags:
      - 'v*'  # Always run on version tags
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'applications/**'  # Include app-specific code directories
      - 'scripts/**'
      - 'docker-compose*.yml'
      - 'Dockerfile*'
      - '.github/workflows/ci.yml'  # Run if CI workflow itself changes
  pull_request:
    branches: [main, develop]
    paths:
      - 'backend/**'
      - 'frontend/**'
      - 'applications/**'  # Include app-specific code directories
      - 'scripts/**'
      - 'docker-compose*.yml'
      - 'Dockerfile*'
      - '.github/workflows/ci.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

# Cancel in-progress runs of the same workflow
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '20'
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  # ===========================================================================
  # Change Detection (run first to determine what to execute)
  # ===========================================================================
  
  detect-changes:
    name: Detect Code Changes
    runs-on: ubuntu-latest
    outputs:
      app-code: ${{ steps.filter.outputs.app-code }}
      backend-code: ${{ steps.filter.outputs.backend-code }}
      frontend-code: ${{ steps.filter.outputs.frontend-code }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for path filtering
      
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            app-code:
              - 'backend/**'
              - 'frontend/**'
              - 'applications/**'  # Include all app-specific code
              - 'Dockerfile*'
              - 'docker-compose*.yml'
            backend-code:
              - 'backend/**'
              - 'applications/*/backend/**'
              - '**/requirements*.txt'
              - '**/pyproject.toml'
              - '**/pytest.ini'
              - '**/Dockerfile'  # Backend Dockerfiles
            frontend-code:
              - 'frontend/**'
              - 'applications/*/frontend/**'
              - '**/package.json'
              - '**/package-lock.json'
              - '**/vite.config.*'
              - '**/Dockerfile'  # Frontend Dockerfiles

  # ===========================================================================
  # Code Quality Checks
  # ===========================================================================
  
  code-quality:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    needs: [detect-changes]
    # Run if any app code changed (backend OR frontend), or on version tags, or manual dispatch
    if: |
      (needs.detect-changes.outputs.backend-code == 'true' ||
       needs.detect-changes.outputs.frontend-code == 'true' ||
       startsWith(github.ref, 'refs/tags/v') ||
       github.event_name == 'workflow_dispatch')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better analysis
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: backend/requirements-dev.txt
      
      - name: Install Python dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-dev.txt
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install Node.js dependencies
        working-directory: ./frontend
        run: npm ci
      
      # Python code quality - FAST (Ruff + Black)
      - name: Run Ruff linter âš¡ (replaces Flake8, Pylint, isort)
        working-directory: ./backend
        run: ruff check . --output-format=github
      
      - name: Check Python code formatting (Black)
        working-directory: ./backend
        run: |
          echo "::notice::Formatting code with Black..."
          black .
          if [ -n "$(git status --porcelain backend/)" ]; then
            echo "::error::Code was reformatted by Black. Changes:"
            git diff backend/
            echo ""
            echo "::error::Please commit these formatting changes."
            exit 1
          else
            echo "::notice::Code is already properly formatted."
          fi
      
      # JavaScript code quality - FAST (ESLint + Prettier)
      - name: Run ESLint
        working-directory: ./frontend
        run: npm run lint
      
      - name: Check JavaScript formatting (Prettier)
        working-directory: ./frontend
        run: |
          npm run format:check || (echo "âš ï¸  Formatting issues found. Run 'npm run format' locally with Node 20+ to fix." && exit 1)
      
      # Dependency Auditing
      - name: Audit Python dependencies
        working-directory: ./backend
        continue-on-error: true  # Report but don't fail on vulnerabilities
        run: |
          pip install pip-audit
          pip-audit -r requirements.txt --desc on || echo "âš ï¸  Vulnerabilities found in Python dependencies"
      
      - name: Audit Node.js dependencies
        working-directory: ./frontend
        continue-on-error: true  # Report but don't fail on vulnerabilities
        run: |
          npm audit --audit-level=high || echo "âš ï¸  Vulnerabilities found in Node.js dependencies"
      
      # App-specific Python code quality
      - name: Run Ruff linter for app backends
        continue-on-error: true
        run: |
          for app_dir in applications/*/backend; do
            if [ -d "$app_dir" ]; then
              app_name=$(basename $(dirname "$app_dir"))
              echo "::group::Linting $app_name backend"
              if [ -f "$app_dir/ruff.toml" ] || [ -f "$app_dir/pyproject.toml" ]; then
                ruff check "$app_dir" --output-format=github || echo "::warning::Linting failed for $app_name backend"
              else
                echo "::notice::No ruff config found for $app_name, using default"
                ruff check "$app_dir" --output-format=github || echo "::warning::Linting failed for $app_name backend"
              fi
              echo "::endgroup::"
            fi
          done
      
      - name: Check Python formatting for app backends
        continue-on-error: true
        run: |
          for app_dir in applications/*/backend; do
            if [ -d "$app_dir" ]; then
              app_name=$(basename $(dirname "$app_dir"))
              echo "::group::Formatting check for $app_name backend"
              black --check "$app_dir" || echo "::warning::Formatting issues in $app_name backend"
              echo "::endgroup::"
            fi
          done
      
      # App-specific JavaScript code quality
      - name: Run ESLint for app frontends
        continue-on-error: true
        run: |
          for app_dir in applications/*/frontend; do
            if [ -d "$app_dir" ] && [ -f "$app_dir/package.json" ]; then
              app_name=$(basename $(dirname "$app_dir"))
              echo "::group::Linting $app_name frontend"
              cd "$app_dir"
              if npm run | grep -q "lint"; then
                npm run lint || echo "::warning::Linting failed for $app_name frontend"
              else
                echo "::notice::No lint script found for $app_name frontend"
              fi
              cd - > /dev/null
              echo "::endgroup::"
            fi
          done
      
      - name: Check JavaScript formatting for app frontends
        continue-on-error: true
        run: |
          for app_dir in applications/*/frontend; do
            if [ -d "$app_dir" ] && [ -f "$app_dir/package.json" ]; then
              app_name=$(basename $(dirname "$app_dir"))
              echo "::group::Formatting check for $app_name frontend"
              cd "$app_dir"
              if npm run | grep -q "format:check"; then
                npm run format:check || echo "::warning::Formatting issues in $app_name frontend"
              else
                echo "::notice::No format:check script found for $app_name frontend"
              fi
              cd - > /dev/null
              echo "::endgroup::"
            fi
          done
      
      - name: Check for secrets in code
        if: github.event.before != github.sha
        uses: trufflesecurity/trufflehog@v3.63.7
        with:
          path: ./
          base: ${{ github.event.pull_request.base.sha || github.event.before || 'HEAD~1' }}
          head: ${{ github.event.pull_request.head.sha || github.sha }}
          extra_args: --only-verified
        continue-on-error: true

  # ===========================================================================
  # Backend Testing
  # ===========================================================================
  
  backend-tests:
    name: Backend Tests
    runs-on: ubuntu-latest
    needs: [detect-changes]
    # Only run if backend code changed, or on version tags, or manual dispatch
    if: |
      needs.detect-changes.outputs.backend-code == 'true' ||
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch'
    strategy:
      matrix:
        test-type: [unit, integration]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: backend/requirements-dev.txt
      
      - name: Install dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-dev.txt
      
      - name: Run unit tests
        if: matrix.test-type == 'unit'
        working-directory: ./backend
        env:
          TESTING: 'true'
          RATE_LIMIT_ENABLED: 'false'
        run: |
          pytest -m unit \
            --verbose \
            --tb=short \
            --cov=. \
            --cov-report=xml \
            --cov-report=html \
            --cov-report=term-missing \
            --junitxml=junit-unit.xml \
            tests/
      
      - name: Run integration tests
        if: matrix.test-type == 'integration'
        working-directory: ./backend
        env:
          TESTING: 'false'
          BACKEND_URL: 'http://localhost:8000'
        run: |
          # Start services for integration tests
          cd ..
          docker compose up -d database backend
          
          # Wait for services
          timeout 60 bash -c 'until curl -f http://localhost:8000/health; do sleep 2; done'
          
          # Run integration tests
          cd backend
          pytest -m integration \
            --verbose \
            --tb=short \
            --junitxml=junit-integration.xml \
            tests/test_integration.py
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-test-results-${{ matrix.test-type }}
          path: |
            backend/junit-*.xml
            backend/htmlcov/
            backend/coverage.xml
      
      - name: Upload coverage to Codecov
        if: matrix.test-type == 'unit'
        uses: codecov/codecov-action@v4
        with:
          files: ./backend/coverage.xml
          flags: backend
          name: backend-coverage
          fail_ci_if_error: false
      
      - name: Stop services
        if: always() && matrix.test-type == 'integration'
        run: docker compose down -v

  # ===========================================================================
  # App-Specific Backend Testing
  # ===========================================================================
  
  app-backend-tests:
    name: App-Specific Backend Tests
    runs-on: ubuntu-latest
    needs: [detect-changes]
    # Only run if backend code changed, or on version tags, or manual dispatch
    if: |
      needs.detect-changes.outputs.backend-code == 'true' ||
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Detect app backends with tests
        id: detect-apps
        run: |
          APPS=$(find applications -mindepth 2 -maxdepth 2 -type d -name "backend" -exec dirname {} \; | xargs -n1 basename | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "apps=$APPS" >> $GITHUB_OUTPUT
          echo "::notice::Detected app backends: $APPS"
      
      - name: Run tests for each app backend
        if: steps.detect-apps.outputs.apps != '[]'
        continue-on-error: true
        run: |
          for app_name in $(echo "${{ steps.detect-apps.outputs.apps }}" | jq -r '.[]'); do
            app_backend_dir="applications/$app_name/backend"
            
            if [ ! -d "$app_backend_dir" ]; then
              echo "::warning::Backend directory not found: $app_backend_dir"
              continue
            fi
            
            if [ ! -d "$app_backend_dir/tests" ] && [ ! -f "$app_backend_dir/pytest.ini" ]; then
              echo "::notice::No tests found for $app_name backend, skipping"
              continue
            fi
            
            echo "::group::Testing $app_name backend"
            
            # Install dependencies if requirements exist
            if [ -f "$app_backend_dir/requirements.txt" ]; then
              echo "Installing dependencies for $app_name..."
              pip install -r "$app_backend_dir/requirements.txt"
            fi
            
            if [ -f "$app_backend_dir/requirements-dev.txt" ]; then
              echo "Installing dev dependencies for $app_name..."
              pip install -r "$app_backend_dir/requirements-dev.txt"
            fi
            
            # Run tests
            cd "$app_backend_dir"
            if [ -f "pytest.ini" ] || [ -d "tests" ]; then
              echo "Running tests for $app_name backend..."
              pytest \
                --verbose \
                --tb=short \
                --junitxml=junit-$app_name.xml \
                tests/ || echo "::warning::Tests failed for $app_name backend"
            fi
            cd - > /dev/null
            
            echo "::endgroup::"
          done
      
      - name: Upload app backend test results
        if: always() && steps.detect-apps.outputs.apps != '[]'
        uses: actions/upload-artifact@v4
        with:
          name: app-backend-test-results
          path: applications/*/backend/junit-*.xml
          if-no-files-found: ignore

  # ===========================================================================
  # Frontend Testing
  # ===========================================================================
  
  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest
    needs: [detect-changes]
    # Only run if frontend code changed, or on version tags, or manual dispatch
    if: |
      needs.detect-changes.outputs.frontend-code == 'true' ||
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Run tests with coverage
        working-directory: ./frontend
        run: npm test -- --coverage --watchAll=false --ci --maxWorkers=50%
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-test-results
          path: |
            frontend/coverage/
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./frontend/coverage/coverage-final.json
          flags: frontend
          name: frontend-coverage
          fail_ci_if_error: false

  # ===========================================================================
  # App-Specific Frontend Testing
  # ===========================================================================
  
  app-frontend-tests:
    name: App-Specific Frontend Tests
    runs-on: ubuntu-latest
    needs: [detect-changes]
    # Only run if frontend code changed, or on version tags, or manual dispatch
    if: |
      needs.detect-changes.outputs.frontend-code == 'true' ||
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Detect app frontends with tests
        id: detect-apps
        run: |
          APPS=$(find applications -mindepth 2 -maxdepth 2 -type d -name "frontend" -exec dirname {} \; | xargs -n1 basename | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "apps=$APPS" >> $GITHUB_OUTPUT
          echo "::notice::Detected app frontends: $APPS"
      
      - name: Run tests for each app frontend
        if: steps.detect-apps.outputs.apps != '[]'
        continue-on-error: true
        run: |
          for app_name in $(echo "${{ steps.detect-apps.outputs.apps }}" | jq -r '.[]'); do
            app_frontend_dir="applications/$app_name/frontend"
            
            if [ ! -d "$app_frontend_dir" ]; then
              echo "::warning::Frontend directory not found: $app_frontend_dir"
              continue
            fi
            
            if [ ! -f "$app_frontend_dir/package.json" ]; then
              echo "::notice::No package.json found for $app_name frontend, skipping"
              continue
            fi
            
            echo "::group::Testing $app_name frontend"
            
            # Install dependencies
            cd "$app_frontend_dir"
            echo "Installing dependencies for $app_name frontend..."
            npm ci || echo "::warning::npm ci failed for $app_name, trying npm install"
            npm install || echo "::warning::npm install failed for $app_name"
            
            # Run tests if test script exists
            if npm run | grep -q "test"; then
              echo "Running tests for $app_name frontend..."
              npm test -- --coverage --watchAll=false --ci --maxWorkers=50% || echo "::warning::Tests failed for $app_name frontend"
            else
              echo "::notice::No test script found in $app_name frontend package.json"
            fi
            
            cd - > /dev/null
            
            echo "::endgroup::"
          done
      
      - name: Upload app frontend test results
        if: always() && steps.detect-apps.outputs.apps != '[]'
        uses: actions/upload-artifact@v4
        with:
          name: app-frontend-test-results
          path: applications/*/frontend/coverage/
          if-no-files-found: ignore

  # ===========================================================================
  # Build Metadata Preparation
  # ===========================================================================
  
  prepare-build:
    name: Prepare Build Metadata
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.metadata.outputs.version }}
      commit: ${{ steps.metadata.outputs.commit }}
      branch: ${{ steps.metadata.outputs.branch }}
      build_date: ${{ steps.metadata.outputs.build_date }}
      is_release: ${{ steps.metadata.outputs.is_release }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git describe
      
      - name: Generate build metadata
        id: metadata
        run: |
          # Determine version
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION="${{ github.ref_name }}"
            IS_RELEASE="true"
          elif [[ "${{ github.ref }}" == refs/heads/main ]]; then
            VERSION="main-$(git rev-parse --short HEAD)"
            IS_RELEASE="false"
          else
            VERSION="dev-$(git rev-parse --short HEAD)"
            IS_RELEASE="false"
          fi
          
          # Get git metadata
          COMMIT=$(git rev-parse --short HEAD)
          BRANCH=${GITHUB_REF#refs/heads/}
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          
          # Output for use in other jobs
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "commit=${COMMIT}" >> $GITHUB_OUTPUT
          echo "branch=${BRANCH}" >> $GITHUB_OUTPUT
          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
          echo "is_release=${IS_RELEASE}" >> $GITHUB_OUTPUT
          
          # Display metadata
          echo "::notice::Build Version: ${VERSION}"
          echo "::notice::Git Commit: ${COMMIT}"
          echo "::notice::Git Branch: ${BRANCH}"
          echo "::notice::Build Date: ${BUILD_DATE}"

      - name: Persist build version for downstream workflows
        run: |
          echo "${{ steps.metadata.outputs.version }}" > build-version.txt
        shell: bash

      - name: Upload build version artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-version
          path: build-version.txt
          retention-days: 7  # Keep artifact for 7 days for deployment workflows
          if-no-files-found: error  # Fail if file doesn't exist

  # ===========================================================================
  # Docker Image Building
  # ===========================================================================
  
  detect-app-images:
    name: Detect Application Images to Build
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      
      - name: Detect images to build
        id: set-matrix
        run: |
          python scripts/detect-app-images.py --format matrix > matrix.json
          echo "matrix<<EOF" >> $GITHUB_OUTPUT
          cat matrix.json >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "::notice::Build matrix:"
          cat matrix.json | jq -r '.include[] | "  - \(.image_name) (\(.type))"'
    
  filter-build-matrix:
    name: Filter Build Matrix
    runs-on: ubuntu-latest
    needs: [detect-changes, detect-app-images]
    outputs:
      matrix: ${{ steps.filter.outputs.matrix }}
    steps:
      - name: Filter matrix by changed code
        id: filter
        run: |
          BACKEND_CHANGED="${{ needs.detect-changes.outputs.backend-code }}"
          FRONTEND_CHANGED="${{ needs.detect-changes.outputs.frontend-code }}"
          APP_CODE_CHANGED="${{ needs.detect-changes.outputs.app-code }}"
          FULL_MATRIX='${{ needs.detect-app-images.outputs.matrix }}'
          
          echo "::group::Change Detection Debug"
          echo "Backend changed: $BACKEND_CHANGED"
          echo "Frontend changed: $FRONTEND_CHANGED"
          echo "App code changed: $APP_CODE_CHANGED"
          echo "Full matrix:"
          echo "$FULL_MATRIX" | jq '.'
          echo "::endgroup::"
          
          # If both changed or tag/manual, use full matrix
          if [ "${{ startsWith(github.ref, 'refs/tags/v') }}" == "true" ] || [ "${{ github.event_name == 'workflow_dispatch' }}" == "true" ]; then
            echo "matrix<<EOF" >> $GITHUB_OUTPUT
            echo "$FULL_MATRIX" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "::notice::Building all images (tag/manual trigger)"
            exit 0
          fi
          
          # Filter matrix based on what changed
          # If app-code changed, we should build all app-specific images (more permissive)
          if [ "$BACKEND_CHANGED" == "true" ] && [ "$FRONTEND_CHANGED" == "true" ]; then
            echo "matrix<<EOF" >> $GITHUB_OUTPUT
            echo "$FULL_MATRIX" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "::notice::Building all images (both backend and frontend changed)"
          elif [ "$BACKEND_CHANGED" == "true" ]; then
            # Only shared backend images (backend/ directory changes affect shared backend only)
            # App-specific backends (applications/*/backend) are built separately when their code changes
            FILTERED=$(echo "$FULL_MATRIX" | jq '.include | map(select(.service == "backend" and .type == "shared")) | {include: .}')
            COUNT=$(echo "$FILTERED" | jq '.include | length')
            if [ "$COUNT" -eq 0 ]; then
              echo "::error::Backend code changed but no shared backend images found in matrix!"
              echo "matrix<<EOF" >> $GITHUB_OUTPUT
              echo "$FULL_MATRIX" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              echo "::warning::Using full matrix as fallback"
            else
              echo "matrix<<EOF" >> $GITHUB_OUTPUT
              echo "$FILTERED" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              echo "::notice::Building only shared backend images ($COUNT image(s))"
            fi
          elif [ "$FRONTEND_CHANGED" == "true" ]; then
            # Only shared frontend images (frontend/ directory changes affect shared frontend only)
            # App-specific frontends (applications/*/frontend) are built separately when their code changes
            FILTERED=$(echo "$FULL_MATRIX" | jq '.include | map(select(.service == "frontend" and .type == "shared")) | {include: .}')
            COUNT=$(echo "$FILTERED" | jq '.include | length')
            if [ "$COUNT" -eq 0 ]; then
              echo "::error::Frontend code changed but no shared frontend images found in matrix!"
              echo "::error::Full matrix was:"
              echo "$FULL_MATRIX" | jq '.'
              echo "matrix<<EOF" >> $GITHUB_OUTPUT
              echo "$FULL_MATRIX" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              echo "::warning::Using full matrix as fallback"
            else
              echo "matrix<<EOF" >> $GITHUB_OUTPUT
              echo "$FILTERED" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              echo "::notice::Building only shared frontend images ($COUNT image(s))"
              echo "::notice::Filtered matrix:"
              echo "$FILTERED" | jq '.'
            fi
          elif [ "$APP_CODE_CHANGED" == "true" ]; then
            # App code changed but path filter didn't detect backend/frontend specifically
            # This can happen with dorny/paths-filter - be more permissive and build all app-specific images
            echo "::warning::App code changed but backend/frontend detection unclear - building all app-specific images"
            FILTERED=$(echo "$FULL_MATRIX" | jq '.include | map(select(.type == "app-specific")) | {include: .}')
            COUNT=$(echo "$FILTERED" | jq '.include | length')
            if [ "$COUNT" -eq 0 ]; then
              echo "::warning::No app-specific images found, using full matrix"
              echo "matrix<<EOF" >> $GITHUB_OUTPUT
              echo "$FULL_MATRIX" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              echo "matrix<<EOF" >> $GITHUB_OUTPUT
              echo "$FILTERED" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              echo "::notice::Building app-specific images ($COUNT image(s))"
            fi
          else
            echo "matrix={\"include\": []}" >> $GITHUB_OUTPUT
            echo "::warning::No code changes detected, skipping builds"
            echo "::warning::This might be a path filter issue - check the detect-changes job output"
          fi

  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [code-quality, backend-tests, frontend-tests, app-backend-tests, app-frontend-tests, prepare-build, detect-changes, filter-build-matrix]
    # Build images if backend OR frontend code changed, or on version tags, or manual dispatch
    # Also check that prerequisite jobs succeeded (or were skipped)
    if: |
      (needs.detect-changes.outputs.backend-code == 'true' ||
       needs.detect-changes.outputs.frontend-code == 'true' ||
       startsWith(github.ref, 'refs/tags/v') ||
       github.event_name == 'workflow_dispatch') &&
      (needs.code-quality.result == 'success' || needs.code-quality.result == 'skipped') &&
      (needs.backend-tests.result == 'success' || needs.backend-tests.result == 'skipped') &&
      (needs.frontend-tests.result == 'success' || needs.frontend-tests.result == 'skipped') &&
      (needs.app-backend-tests.result == 'success' || needs.app-backend-tests.result == 'skipped') &&
      (needs.app-frontend-tests.result == 'success' || needs.app-frontend-tests.result == 'skipped')
    strategy:
      matrix: ${{ fromJson(needs.filter-build-matrix.outputs.matrix) }}
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository_owner }}/${{ matrix.image_name }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,prefix={{branch}}-
            type=raw,value=${{ needs.prepare-build.outputs.version }}
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            BUILD_VERSION=${{ needs.prepare-build.outputs.version }}
            GIT_COMMIT=${{ needs.prepare-build.outputs.commit }}
            GIT_BRANCH=${{ needs.prepare-build.outputs.branch }}
            BUILD_DATE=${{ needs.prepare-build.outputs.build_date }}
          cache-from: type=gha,scope=${{ matrix.image_name }}
          cache-to: type=gha,mode=max,scope=${{ matrix.image_name }}
          platforms: linux/amd64
      
      - name: Export image for testing
        if: github.event_name == 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          tags: ${{ matrix.image_name }}:test
          build-args: |
            BUILD_VERSION=${{ needs.prepare-build.outputs.version }}
            GIT_COMMIT=${{ needs.prepare-build.outputs.commit }}
            GIT_BRANCH=${{ needs.prepare-build.outputs.branch }}
            BUILD_DATE=${{ needs.prepare-build.outputs.build_date }}
          cache-from: type=gha,scope=${{ matrix.image_name }}
          load: true

  # ===========================================================================
  # End-to-End Tests
  # ===========================================================================
  
  e2e-tests:
    name: End-to-End Tests
    runs-on: ubuntu-latest
    needs: [build-images, prepare-build, detect-changes, filter-build-matrix]
    # Only run E2E tests if app code changed (backend OR frontend), or on version tags, or manual dispatch
    # Check if build-images succeeded OR was skipped (which means matrix was empty/filtered but that's OK)
    if: |
      (needs.detect-changes.outputs.backend-code == 'true' ||
       needs.detect-changes.outputs.frontend-code == 'true' ||
       startsWith(github.ref, 'refs/tags/v') ||
       github.event_name == 'workflow_dispatch') &&
      (needs.build-images.result == 'success' || needs.build-images.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Start services with docker compose
        env:
          BUILD_VERSION: ${{ needs.prepare-build.outputs.version }}
          GIT_COMMIT: ${{ needs.prepare-build.outputs.commit }}
          GIT_BRANCH: ${{ needs.prepare-build.outputs.branch }}
          BUILD_DATE: ${{ needs.prepare-build.outputs.build_date }}
        run: |
          docker compose up -d --build
      
      - name: Wait for services to be healthy
        run: |
          echo "Waiting for services to be healthy..."
          
          echo "=== Waiting for database ==="
          timeout 120 bash -c '
            until docker compose ps database | grep -q "healthy"; do 
              echo "Waiting for database..."; 
              sleep 2; 
            done
          '
          echo "âœ“ Database is healthy"
          
          echo "=== Waiting for backend ==="
          timeout 120 bash -c '
            until docker compose ps backend | grep -q "healthy"; do 
              echo "Waiting for backend..."; 
              sleep 2; 
            done
          '
          echo "âœ“ Backend is healthy"
          
          echo "=== Waiting for frontend ==="
          echo "Container status before wait:"
          docker compose ps frontend
          
          timeout 120 bash -c '
            counter=0
            until docker compose ps frontend | grep -q "healthy"; do 
              counter=$((counter + 1))
              echo "Waiting for frontend... (attempt $counter)"
              
              # Every 10 attempts, show detailed debug info
              if [ $((counter % 10)) -eq 0 ]; then
                echo "--- Debug Info (attempt $counter) ---"
                echo "Container status:"
                docker compose ps frontend
                echo "Health check status:"
                docker inspect --format="{{json .State.Health}}" frontend 2>/dev/null | jq . || echo "No health info available"
                echo "Recent logs:"
                docker compose logs --tail=20 frontend
                echo "---"
              fi
              
              sleep 2
            done
          '
          echo "âœ“ Frontend is healthy"
      
      - name: Verify service health
        run: |
          echo "=== Service Status ==="
          docker compose ps
          
          echo -e "\n=== Database Health ==="
          docker compose exec -T database pg_isready -U appuser -d appdb
          
          echo -e "\n=== Backend Health ==="
          curl -f http://localhost:8000/health | jq .
          
          echo -e "\n=== Backend Version ==="
          curl -f http://localhost:8000/version | jq .
          
          echo -e "\n=== Frontend Health ==="
          curl -f http://localhost:3000/ > /dev/null
          
          echo -e "\n=== Frontend Version ==="
          curl -f http://localhost:3000/version.json | jq .
      
      - name: Run E2E API tests
        run: |
          echo "=== Testing Hello Endpoint ==="
          response=$(curl -s http://localhost:8000/api/hello)
          echo "$response" | jq .
          echo "$response" | jq -e '.message == "hello from backend"'
          
          echo "=== Testing Greet Endpoint ==="
          response=$(curl -s http://localhost:8000/api/greet/E2ETest)
          echo "$response" | jq .
          echo "$response" | jq -e '.message == "Hello, E2ETest!"'
          
          echo "=== Testing Get Greetings ==="
          response=$(curl -s http://localhost:8000/api/greetings)
          echo "$response" | jq .
          echo "$response" | jq -e '.total > 0'
          
          echo "=== Testing User Greetings ==="
          response=$(curl -s http://localhost:8000/api/greetings/E2ETest)
          echo "$response" | jq .
          echo "$response" | jq -e '.count > 0'
      
      - name: Test version metadata
        run: |
          echo "=== Verify Backend Version ==="
          response=$(curl -s http://localhost:8000/version)
          echo "$response" | jq .
          echo "$response" | jq -e '.version == "${{ needs.prepare-build.outputs.version }}"'
          echo "$response" | jq -e '.commit == "${{ needs.prepare-build.outputs.commit }}"'
          
          echo "=== Verify Frontend Version ==="
          response=$(curl -s http://localhost:3000/version.json)
          echo "$response" | jq .
          echo "$response" | jq -e '.version == "${{ needs.prepare-build.outputs.version }}"'
      
      - name: Show service logs on failure
        if: failure()
        run: |
          echo "=== Container Status ==="
          docker compose ps -a
          
          echo -e "\n=== Container Health Details ==="
          for service in database backend frontend; do
            echo "--- $service health ---"
            docker inspect --format="{{json .State.Health}}" $service 2>/dev/null | jq . || echo "No health info for $service"
          done
          
          echo -e "\n=== Full Docker Compose Logs ==="
          docker compose logs --no-color
          
          echo -e "\n=== Frontend Container Inspect ==="
          docker inspect frontend 2>/dev/null | jq '.[0].State' || echo "Frontend container not found"
      
      - name: Stop services
        if: always()
        run: docker compose down -v

  # ===========================================================================
  # Security Scanning
  # ===========================================================================
  
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: [build-images, detect-changes, detect-app-images, filter-build-matrix]
    # Only scan if app code changed (backend OR frontend), or on version tags, or manual dispatch
    # Check if build-images succeeded OR was skipped (which means matrix was empty/filtered but that's OK)
    # Also check that the filtered matrix has at least one image to scan
    if: |
      github.event_name != 'pull_request' &&
      (needs.detect-changes.outputs.backend-code == 'true' ||
       needs.detect-changes.outputs.frontend-code == 'true' ||
       startsWith(github.ref, 'refs/tags/v') ||
       github.event_name == 'workflow_dispatch') &&
      (needs.build-images.result == 'success' || needs.build-images.result == 'skipped')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Get images to scan
        id: get-images
        run: |
          BUILD_MATRIX='${{ needs.detect-app-images.outputs.matrix }}'
          FIRST_IMAGE=$(echo "$BUILD_MATRIX" | jq -r '.include[0].image_name // "ci-backend"')
          ALL_IMAGES=$(echo "$BUILD_MATRIX" | jq -r '.include[] | "\(.image_name)"' | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "first_image=$FIRST_IMAGE" >> $GITHUB_OUTPUT
          echo "all_images=$ALL_IMAGES" >> $GITHUB_OUTPUT
          echo "::notice::Will scan all images, uploading $FIRST_IMAGE to GitHub Security"
      
      - name: Run Trivy for primary image (GitHub Security upload)
        continue-on-error: true
        uses: aquasecurity/trivy-action@0.29.0
        with:
          image-ref: 'ghcr.io/${{ github.repository_owner }}/${{ steps.get-images.outputs.first_image }}:latest'
          format: 'sarif'
          output: 'trivy-results-primary.sarif'
      
      - name: Upload Trivy results to GitHub Security
        continue-on-error: true
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: 'trivy-results-primary.sarif'
      
      - name: Run Trivy for all images (detailed reports)
        continue-on-error: true
        run: |
          BUILD_MATRIX='${{ needs.detect-app-images.outputs.matrix }}'
          for image_name in $(echo "$BUILD_MATRIX" | jq -r '.include[] | "\(.image_name)"'); do
            echo "::group::Trivy scan for $image_name"
            # Note: Using Trivy action would require a matrix, so we'll use docker run
            # For now, we'll just log that we would scan this image
            # Full scanning is done via the primary image upload above
            echo "Image: ghcr.io/${{ github.repository_owner }}/${image_name}:latest"
            echo "::notice::Full scan results available in GitHub Security (primary image) and artifacts"
            echo "::endgroup::"
          done
      
      - name: Upload Trivy results as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-security-reports
          path: trivy-results-*.sarif
          if-no-files-found: ignore
          retention-days: 30
      
      # Docker Scout - Advanced vulnerability analysis and recommendations
      - name: Login to Docker Hub (for Scout)
        if: github.event_name != 'pull_request'
        continue-on-error: true
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Docker Scout CVE Analysis
        continue-on-error: true
        run: |
          BUILD_MATRIX='${{ needs.detect-app-images.outputs.matrix }}'
          for image_name in $(echo "$BUILD_MATRIX" | jq -r '.include[] | "\(.image_name)"'); do
            echo "::group::Docker Scout CVE Analysis for $image_name"
            docker scout cves \
              --only-severity critical,high \
              "ghcr.io/${{ github.repository_owner }}/${image_name}:latest" || echo "::warning::Docker Scout failed for $image_name"
            echo "::endgroup::"
          done
      
      - name: Docker Scout Recommendations
        continue-on-error: true
        run: |
          BUILD_MATRIX='${{ needs.detect-app-images.outputs.matrix }}'
          for image_name in $(echo "$BUILD_MATRIX" | jq -r '.include[] | "\(.image_name)"'); do
            echo "::group::Docker Scout Recommendations for $image_name"
            docker scout recommendations \
              "ghcr.io/${{ github.repository_owner }}/${image_name}:latest" || echo "::warning::Docker Scout recommendations failed for $image_name"
            echo "::endgroup::"
          done

  # ===========================================================================
  # Release & Deployment
  # ===========================================================================
  
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [e2e-tests, prepare-build]
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Generate changelog
        id: changelog
        run: |
          # Simple changelog generation
          echo "## What's Changed" > CHANGELOG.txt
          git log --pretty=format:"* %s" $(git describe --tags --abbrev=0 HEAD^)..HEAD >> CHANGELOG.txt
          cat CHANGELOG.txt
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          body_path: CHANGELOG.txt
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ===========================================================================
  # Summary
  # ===========================================================================
  
  summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: [e2e-tests, prepare-build, detect-changes, build-images, code-quality, backend-tests, frontend-tests, app-backend-tests, app-frontend-tests, detect-app-images, filter-build-matrix]
    if: always()
    
    steps:
      - name: Create summary
        run: |
          echo "## ðŸš€ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`${{ needs.prepare-build.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** \`${{ needs.prepare-build.outputs.commit }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** \`${{ needs.prepare-build.outputs.branch }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Build Date:** \`${{ needs.prepare-build.outputs.build_date }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          APP_CODE_CHANGED="${{ needs.detect-changes.outputs.app-code }}"
          IS_TAG="${{ startsWith(github.ref, 'refs/tags/v') }}"
          IS_MANUAL="${{ github.event_name == 'workflow_dispatch' }}"
          
          if [ "$APP_CODE_CHANGED" == "true" ] || [ "$IS_TAG" == "true" ] || [ "$IS_MANUAL" == "true" ]; then
            echo "### âœ… Application Code Changed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“¦ Images Built" >> $GITHUB_STEP_SUMMARY
            
            # Get images from filtered build matrix (what was actually built)
            # Use filtered matrix if available, otherwise fall back to full matrix
            FILTERED_MATRIX='${{ needs.filter-build-matrix.outputs.matrix }}'
            FULL_MATRIX='${{ needs.detect-app-images.outputs.matrix }}'
            VERSION='${{ needs.prepare-build.outputs.version }}'
            OWNER='${{ github.repository_owner }}'
            
            # Prefer filtered matrix (what was actually built), fall back to full matrix
            if [ -n "$FILTERED_MATRIX" ] && [ "$FILTERED_MATRIX" != "null" ] && [ "$FILTERED_MATRIX" != "{\"include\": []}" ]; then
              BUILD_MATRIX="$FILTERED_MATRIX"
            elif [ -n "$FULL_MATRIX" ] && [ "$FULL_MATRIX" != "null" ]; then
              BUILD_MATRIX="$FULL_MATRIX"
            else
              BUILD_MATRIX=""
            fi
            
            if [ -n "$BUILD_MATRIX" ] && [ "$BUILD_MATRIX" != "null" ]; then
              # Use jq to extract data, then construct markdown in bash to avoid escaping issues
              echo "$BUILD_MATRIX" | jq -r --arg version "$VERSION" --arg owner "$OWNER" '.include[] | "\($owner)|\(.image_name)|\($version)|\(.type)"' | while IFS='|' read -r owner_name image_name img_version img_type; do
                echo "- \`ghcr.io/${owner_name}/${image_name}:${img_version}\` (${img_type})" >> $GITHUB_STEP_SUMMARY
              done
            else
              # Fallback to shared images if matrix not available
              echo "- \`ghcr.io/${{ github.repository_owner }}/ci-backend:${{ needs.prepare-build.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
              echo "- \`ghcr.io/${{ github.repository_owner }}/ci-frontend:${{ needs.prepare-build.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### â­ï¸  Workflow Optimized" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Tests, builds, and scans were **skipped** because no application code changed." >> $GITHUB_STEP_SUMMARY
            echo "Only workflow/infrastructure files were modified in this commit." >> $GITHUB_STEP_SUMMARY
          fi
