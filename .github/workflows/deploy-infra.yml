name: Deploy Infrastructure (deploy-infra)

# This workflow manages infrastructure deployments (VPC, OIDC, DNS/ACM, ECS Fargate)
# It is manual-only for safety and control over infrastructure changes.

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'dev'
        type: choice
        options: [dev, staging, production]
      module_path:
        description: 'Terraform module to deploy (e.g., 01-vpc, 04-ecs-fargate)'
        required: true
        type: string
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options: [plan, apply, destroy]

jobs:
  deploy:
    name: ${{ inputs.action }} - ${{ inputs.module_path }}
    runs-on: ubuntu-latest
    
    permissions:
      id-token: write
      contents: read

    environment:
      name: ${{ inputs.environment }}

    steps:
      - name: Checkout CI repository
        uses: actions/checkout@v4

      - name: Debug GitHub context
        run: |
          echo "repository: $GITHUB_REPOSITORY"
          echo "ref:        $GITHUB_REF"
          echo "event_name: $GITHUB_EVENT_NAME"

      - name: Debug AWS role and region
        run: |
          echo "Has AWS_ROLE_ARN: $([ -n \"$AWS_ROLE_ARN\" ] && echo yes || echo no)"
          echo "AWS_ROLE_ARN length: ${#AWS_ROLE_ARN}"
          echo "AWS_REGION: $AWS_REGION"
        env:
          AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}

      - name: Terraform Setup
        uses: ./.github/actions/terraform-setup
        with:
          devops_repo: ${{ secrets.DEVOPS_REPO_NAME || 'orshalit/DEVOPS' }}
          devops_repo_key: ${{ secrets.DEVOPS_REPO_KEY }}
          aws_role_arn: ${{ secrets.AWS_ROLE_ARN }}
          aws_region: ${{ secrets.AWS_REGION }}
          terraform_version: '1.6.0'

      - name: Terraform Format
        id: fmt
        run: |
          TERRAFORM_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          
          echo "::notice::Formatting Terraform files in $TERRAFORM_DIR..."
          
          # Format all Terraform files
          terraform fmt -recursive "$TERRAFORM_DIR"
          
          # Check if any files were modified by comparing before/after
          cd DEVOPS
          # Get list of files that would be formatted (all .tf and .tfvars files)
          FORMATTED_FILES=$(find "live/${{ inputs.environment }}/${{ inputs.module_path }}" -type f \( -name "*.tf" -o -name "*.tfvars" \) 2>/dev/null || true)
          
          if [ -z "$FORMATTED_FILES" ]; then
            echo "::notice::No Terraform files found to format"
            exit 0
          fi
          
          # Check git status for changes in the terraform directory
          if git diff --quiet "live/${{ inputs.environment }}/${{ inputs.module_path }}"; then
            echo "::notice::âœ“ All Terraform files are properly formatted"
          else
            echo "::error::â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "::error::â•‘  âš ï¸  TERRAFORM FORMATTING ISSUES DETECTED  âš ï¸  â•‘"
            echo "::error::â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "::error::The following files need formatting:"
            git status --short "live/${{ inputs.environment }}/${{ inputs.module_path }}" | while read -r line; do
              echo "::error::  â€¢ $line"
            done
            echo ""
            echo "::error::Files have been automatically formatted in this workflow run."
            echo "::error::"
            echo "::error::To fix this:"
            echo "::error::  1. Run 'terraform fmt -recursive' locally in: $TERRAFORM_DIR"
            echo "::error::  2. Commit the formatted files"
            echo "::error::  3. Push and re-run this workflow"
            echo ""
            echo "::group::Show formatted changes"
            git diff "live/${{ inputs.environment }}/${{ inputs.module_path }}"
            echo "::endgroup::"
            exit 1
          fi

      - name: Terraform Init
        id: init
        run: terraform -chdir=DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }} init

      - name: Check for terraform.tfvars
        id: check_tfvars
        run: |
          if [ -f "DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}/terraform.tfvars" ]; then
            echo "tfvars_exists=true" >> $GITHUB_OUTPUT
          else
            echo "tfvars_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Check for services.generated.tfvars
        id: check_services_tfvars
        run: |
          if [ -f "DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}/services.generated.tfvars" ]; then
            echo "services_tfvars_exists=true" >> $GITHUB_OUTPUT
          else
            echo "services_tfvars_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Check if services is empty
        id: check_services_empty
        if: inputs.action == 'plan' || inputs.action == 'apply'
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          
          # Check if services.generated.tfvars exists and has non-empty services
          if [ -f "$PLAN_DIR/services.generated.tfvars" ]; then
            # Check if services map is empty (services = {})
            # An empty services map will have "services = {}" on a single line or just "{}" after "services ="
            # Service keys may be quoted (e.g., "legacy::api") or unquoted (e.g., legacy::api)
            if grep -qE "^\s*services\s*=\s*\{\}\s*$" "$PLAN_DIR/services.generated.tfvars" || \
               (grep -qE "^\s*services\s*=\s*\{$" "$PLAN_DIR/services.generated.tfvars" && \
                ! grep -A 10 "services = {" "$PLAN_DIR/services.generated.tfvars" | grep -qE "^\s+(\"[^\"]+::[^\"]+\"|[a-zA-Z0-9_-]+::[a-zA-Z0-9_-]+)\s*=\s*\{"); then
              echo "services_empty=true" >> $GITHUB_OUTPUT
              echo "::notice::Services map is empty (services = {}), will exclude from var files to avoid Terraform crash"
            else
              echo "services_empty=false" >> $GITHUB_OUTPUT
              echo "::notice::Services map has content"
            fi
          else
            echo "services_empty=true" >> $GITHUB_OUTPUT
            echo "::notice::services.generated.tfvars not found"
          fi

      - name: Terraform Validate
        id: validate
        # Skip validate for ECS Fargate module entirely to avoid Terraform crash
        # This is a known Terraform bug with marked values in conditional expressions
        # terraform plan will catch all validation errors anyway
        if: inputs.module_path != '04-ecs-fargate'
        run: terraform -chdir=DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }} validate -no-color || echo "Terraform validate failed (non-blocking); relying on plan for validation."

      - name: Build var files list
        id: build_var_files
        if: inputs.action == 'plan' || inputs.action == 'apply'
        run: |
          VAR_FILES=""
          if [ "${{ steps.check_tfvars.outputs.tfvars_exists }}" == "true" ]; then
            VAR_FILES="terraform.tfvars"
          fi
          # Only include services.generated.tfvars if it exists AND services is not empty
          # This prevents Terraform crash when services = {} (empty services map)
          if [ "${{ steps.check_services_tfvars.outputs.services_tfvars_exists }}" == "true" ] && \
             [ "${{ steps.check_services_empty.outputs.services_empty }}" != "true" ]; then
            if [ -n "$VAR_FILES" ]; then
              VAR_FILES="$VAR_FILES services.generated.tfvars"
            else
              VAR_FILES="services.generated.tfvars"
            fi
          fi
          echo "var_files=$VAR_FILES" >> $GITHUB_OUTPUT

      - name: Check for existing services in state
        id: check_state_services
        if: |
          (inputs.action == 'plan' || inputs.action == 'apply') &&
          steps.check_services_empty.outputs.services_empty == 'true' &&
          inputs.module_path == '04-ecs-fargate'
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          
          echo "::notice::Checking Terraform state for existing services..."
          
          # Initialize Terraform to access state (without var files to avoid crash)
          cd "$PLAN_DIR"
          terraform init -no-color -input=false > /dev/null 2>&1 || true
          
          # Check if state has any ECS services
          # Use terraform state list to find services (safe even with empty services config)
          if terraform state list -no-color 2>/dev/null | grep -q "aws_ecs_service.services\["; then
            echo "services_in_state=true" >> $GITHUB_OUTPUT
            EXISTING_SERVICES=$(terraform state list -no-color 2>/dev/null | grep "aws_ecs_service.services\[" || echo "")
            echo "existing_services<<EOF" >> $GITHUB_OUTPUT
            echo "$EXISTING_SERVICES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            echo ""
            echo "::error::â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "::error::â•‘  âš ï¸  DEPLOYMENT BLOCKED: DANGEROUS CONFIGURATION DETECTED  âš ï¸  â•‘"
            echo "::error::â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "::error::Problem: services = {} (empty) but Terraform state has existing services!"
            echo ""
            echo "::error::If you proceed, Terraform will DESTROY all existing services:"
            echo "$EXISTING_SERVICES" | while read -r service; do
              echo "::error::  âŒ $service"
            done
            echo ""
            echo "::error::Why this is blocked:"
            echo "::error::  â€¢ Config says: 'deploy zero services' (services = {})"
            echo "::error::  â€¢ State says: 'these services exist'"
            echo "::error::  â€¢ Terraform will destroy existing services to match empty config"
            echo "::error::  â€¢ This is almost certainly a mistake, not intentional"
            echo ""
            echo "::error::Solution - Generate services configuration first:"
            echo "::error::  1. Go to: Actions â†’ 'Create / Update ECS Service (generate DEVOPS PR)'"
            echo "::error::  2. Run the workflow to generate services.generated.tfvars from YAML"
            echo "::error::  3. Review and merge the PR in DEVOPS repository"
            echo "::error::  4. Then run this deployment workflow again"
            echo ""
            echo "::error::This ensures services in config match your YAML definitions."
            exit 1
          else
            echo "services_in_state=false" >> $GITHUB_OUTPUT
            echo "::notice::âœ“ No existing services in state"
            echo "::notice::âœ“ Safe to proceed with empty services config (fresh deployment)"
          fi

      - name: Terraform Refresh State
        id: refresh
        if: |
          (inputs.action == 'plan' || inputs.action == 'apply') &&
          steps.check_state_services.outputs.services_in_state != 'true'
        continue-on-error: true
        timeout-minutes: 5
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          REFRESH_ARGS="-no-color"
          
          # Check if state exists - if not, skip refresh (fresh deployment)
          # Use -chdir consistently instead of cd to avoid path issues
          if ! terraform -chdir="$PLAN_DIR" state list -no-color >/dev/null 2>&1; then
            echo "::notice::No Terraform state found - skipping refresh (fresh deployment)"
            echo "::notice::This is expected when starting with a new/empty state"
            exit 0
          fi
          
          # Use the same var files logic as plan (which excludes empty services.generated.tfvars)
          # This prevents Terraform crash when services = {} (empty services map)
          VAR_FILES="${{ steps.build_var_files.outputs.var_files }}"
          
          if [ -n "$VAR_FILES" ]; then
            for var_file in $VAR_FILES; do
              REFRESH_ARGS="$REFRESH_ARGS -var-file=$var_file"
            done
          fi
          
          echo "::notice::Refreshing Terraform state to sync with AWS..."
          if [ "${{ steps.check_services_empty.outputs.services_empty }}" == "true" ]; then
            echo "::notice::Services map is empty - refreshing infrastructure only (services excluded to avoid crash)"
          else
            echo "::notice::Refreshing all resources including services"
          fi
          
          # Use timeout to prevent hanging (5 minutes should be enough)
          timeout 300 terraform -chdir="$PLAN_DIR" refresh $REFRESH_ARGS || {
            REFRESH_EXITCODE=$?
            if [ $REFRESH_EXITCODE -eq 124 ]; then
              echo "::warning::State refresh timed out after 5 minutes, but continuing with plan..."
            else
              echo "::warning::State refresh failed with exit code $REFRESH_EXITCODE, but continuing with plan..."
            fi
            exit 0  # Don't fail the workflow, just warn
          }
          
          echo "::notice::State refresh completed successfully"

      - name: Detect State Drift (Target Groups)
        id: detect_drift
        if: inputs.action == 'plan' || inputs.action == 'apply'
        continue-on-error: true
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          
          # Only check for ECS Fargate module
          if [[ "${{ inputs.module_path }}" == "04-ecs-fargate" ]]; then
            echo "::notice::Checking for state drift in target group health check paths..."
            
            if [ -f "scripts/verify-target-group-health-checks.sh" ]; then
              chmod +x scripts/verify-target-group-health-checks.sh
              export TERRAFORM_DIR="$PLAN_DIR"
              export ENVIRONMENT="${{ inputs.environment }}"
              
              if scripts/verify-target-group-health-checks.sh; then
                echo "drift_detected=false" >> $GITHUB_OUTPUT
                echo "::notice::No state drift detected"
              else
                echo "drift_detected=true" >> $GITHUB_OUTPUT
                echo "::warning::State drift detected! Consider running terraform refresh manually."
              fi
            else
              echo "::notice::State drift detection script not found, skipping..."
              echo "drift_detected=unknown" >> $GITHUB_OUTPUT
            fi
          else
            echo "::notice::State drift detection only runs for ECS Fargate module"
            echo "drift_detected=skipped" >> $GITHUB_OUTPUT
          fi

      - name: Check for service key mismatches (pre-plan)
        id: check_service_keys
        if: |
          (inputs.action == 'plan' || inputs.action == 'apply') &&
          steps.check_services_empty.outputs.services_empty != 'true' &&
          inputs.module_path == '04-ecs-fargate'
        continue-on-error: true
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          
          echo "::notice::Checking for service key mismatches between state and config..."
          
          # Initialize Terraform to access state
          cd "$PLAN_DIR"
          terraform init -no-color -input=false > /dev/null 2>&1 || true
          
          # Get services from state
          STATE_SERVICES=$(terraform state list -no-color 2>/dev/null | grep "aws_ecs_service.services\[" | sed 's/aws_ecs_service.services\["\(.*\)"\]/\1/' || echo "")
          
          # Get services from config (parse services.generated.tfvars)
          if [ -f "$PLAN_DIR/services.generated.tfvars" ]; then
            CONFIG_SERVICES=$(grep -E '^\s+"[^"]+::[^"]+"\s*=\s*\{' "$PLAN_DIR/services.generated.tfvars" | sed 's/^\s*"\([^"]*\)".*/\1/' || echo "")
          else
            CONFIG_SERVICES=""
          fi
          
          if [ -n "$STATE_SERVICES" ] && [ -n "$CONFIG_SERVICES" ]; then
            # Find services in state but not in config (will be destroyed)
            SERVICES_TO_DESTROY=""
            SERVICES_TO_CREATE=""
            SERVICES_TO_UPDATE=""
            
            for state_svc in $STATE_SERVICES; do
              if ! echo "$CONFIG_SERVICES" | grep -q "^$state_svc$"; then
                SERVICES_TO_DESTROY="$SERVICES_TO_DESTROY $state_svc"
              else
                SERVICES_TO_UPDATE="$SERVICES_TO_UPDATE $state_svc"
              fi
            done
            
            for config_svc in $CONFIG_SERVICES; do
              if ! echo "$STATE_SERVICES" | grep -q "^$config_svc$"; then
                SERVICES_TO_CREATE="$SERVICES_TO_CREATE $config_svc"
              fi
            done
            
            if [ -n "$SERVICES_TO_DESTROY" ]; then
              echo "::warning::âš ï¸ Service key mismatch detected!"
              echo "::warning::The following services in state will be DESTROYED (not in new config):"
              for svc in $SERVICES_TO_DESTROY; do
                echo "::warning::  âŒ $svc"
              done
              echo ""
              echo "::warning::Possible reasons:"
              echo "::warning::  â€¢ Service key changed (e.g., 'api' â†’ 'legacy::api')"
              echo "::warning::  â€¢ Service removed from YAML definitions"
              echo "::warning::  â€¢ Service renamed"
              echo ""
              echo "::warning::To preserve services, consider:"
              echo "::warning::  1. State migration: terraform state mv 'aws_ecs_service.services[\"old-key\"]' 'aws_ecs_service.services[\"new-key\"]'"
              echo "::warning::  2. Or add the service back to YAML if it was accidentally removed"
              echo "key_mismatch=true" >> $GITHUB_OUTPUT
            else
              echo "::notice::âœ“ All services in state match config keys"
              echo "key_mismatch=false" >> $GITHUB_OUTPUT
            fi
            
            if [ -n "$SERVICES_TO_CREATE" ]; then
              echo "::notice::The following NEW services will be CREATED:"
              for svc in $SERVICES_TO_CREATE; do
                echo "::notice::  âž• $svc"
              done
            fi
            
            if [ -n "$SERVICES_TO_UPDATE" ]; then
              echo "::notice::The following services will be UPDATED (if config changed):"
              for svc in $SERVICES_TO_UPDATE; do
                echo "::notice::  ðŸ”„ $svc"
              done
            fi
          else
            echo "::notice::Cannot compare - state or config services list is empty"
            echo "key_mismatch=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Plan
        id: plan
        if: inputs.action == 'plan' || inputs.action == 'apply'
        uses: ./.github/actions/terraform-plan
        with:
          terraform_path: DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}
          var_files: ${{ steps.build_var_files.outputs.var_files }}
          plan_file: "tfplan"
        continue-on-error: true

      - name: Debug Plan - Show Replacement Reasons
        if: inputs.action == 'plan' || inputs.action == 'apply'
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          if [ -f "$PLAN_DIR/tfplan" ]; then
            echo "::group::Debug: Resources Being Replaced"
            echo "Checking for resources that need replacement..."
            terraform -chdir="$PLAN_DIR" show -no-color tfplan | grep -A 10 "must be replaced" || echo "No replacements detected"
            echo "::endgroup::"
            
            echo "::group::Debug: Detailed Plan Output"
            terraform -chdir="$PLAN_DIR" show -no-color tfplan || true
            echo "::endgroup::"
          else
            echo "::notice::Plan file not available for debugging"
          fi

      - name: Add Plan to Summary
        if: inputs.action == 'plan' || (inputs.action == 'apply' && steps.plan.outcome == 'success')
        run: |
          echo "## Terraform Plan Output" >> $GITHUB_STEP_SUMMARY
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          if [ -f "$PLAN_DIR/tfplan" ]; then
            echo '```' >> $GITHUB_STEP_SUMMARY
            terraform -chdir="$PLAN_DIR" show -no-color tfplan >> $GITHUB_STEP_SUMMARY 2>&1
            echo '```' >> $GITHUB_STEP_SUMMARY
            
            # Add replacement analysis to summary
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## ðŸ” Replacement Analysis" >> $GITHUB_STEP_SUMMARY
            REPLACEMENTS=$(terraform -chdir="$PLAN_DIR" show -no-color tfplan 2>&1 | grep -c "must be replaced" || echo "0")
            if [ "$REPLACEMENTS" -gt "0" ]; then
              echo "âš ï¸ **Warning:** $REPLACEMENTS resource(s) will be replaced" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Resources being replaced:" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              terraform -chdir="$PLAN_DIR" show -no-color tfplan 2>&1 | grep -B 2 -A 5 "must be replaced" >> $GITHUB_STEP_SUMMARY || true
              echo '```' >> $GITHUB_STEP_SUMMARY
            else
              echo "âœ… No replacements detected" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "Plan file not available (tfplan not found)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check if plan has changes
        id: plan_changes
        if: inputs.action == 'apply' && steps.plan.outcome == 'success'
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          PLAN_OUTPUT=$(terraform -chdir="$PLAN_DIR" show -no-color tfplan 2>&1)
          
          if echo "$PLAN_OUTPUT" | grep -q "No changes"; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "::notice::No changes detected. Skipping apply."
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "::notice::Changes detected. Proceeding with apply."
            
            # Extract service changes from plan for visibility
            if echo "$PLAN_OUTPUT" | grep -q "aws_ecs_service.services\["; then
              echo ""
              echo "::notice::ðŸ“‹ Service Changes Detected:"
              
              CREATES=$(echo "$PLAN_OUTPUT" | grep -c "aws_ecs_service.services\[.*\] will be created" 2>/dev/null || echo "0")
              DESTROYS=$(echo "$PLAN_OUTPUT" | grep -c "aws_ecs_service.services\[.*\] will be destroyed" 2>/dev/null || echo "0")
              REPLACES=$(echo "$PLAN_OUTPUT" | grep -c "aws_ecs_service.services\[.*\] must be replaced" 2>/dev/null || echo "0")
              
              # Ensure we have valid integers (strip any whitespace/newlines and default to 0)
              CREATES=$(echo "$CREATES" | tr -d '[:space:]' || echo "0")
              DESTROYS=$(echo "$DESTROYS" | tr -d '[:space:]' || echo "0")
              REPLACES=$(echo "$REPLACES" | tr -d '[:space:]' || echo "0")
              
              if [ "${CREATES:-0}" -gt 0 ] 2>/dev/null; then
                echo "::notice::  âž• Services to CREATE: $CREATES"
              fi
              
              if [ "${DESTROYS:-0}" -gt 0 ] 2>/dev/null; then
                echo "::warning::  âŒ Services to DESTROY: $DESTROYS"
                echo "::warning::âš ï¸ This may be due to service key changes (e.g., 'api' â†’ 'legacy::api')"
              fi
              
              if [ "${REPLACES:-0}" -gt 0 ] 2>/dev/null; then
                echo "::warning::  ðŸ”„ Services to REPLACE: $REPLACES"
              fi
            fi
          fi

      - name: Save Terraform state before apply
        id: save_state
        if: inputs.action == 'apply' && steps.plan.outcome == 'success' && steps.plan_changes.outputs.has_changes == 'true'
        run: |
          echo "::notice::Saving Terraform state before apply for potential rollback..."
          # Create a backup of the state file if it exists
          if [ -f "DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}/.terraform/terraform.tfstate" ]; then
            cp "DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}/.terraform/terraform.tfstate" \
               "DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}/.terraform/terraform.tfstate.backup" || true
            echo "state_backed_up=true" >> $GITHUB_OUTPUT
          else
            echo "state_backed_up=false" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Apply
        id: apply
        if: inputs.action == 'apply' && steps.plan.outcome == 'success' && steps.plan_changes.outputs.has_changes == 'true'
        uses: ./.github/actions/terraform-apply
        with:
          terraform_path: DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}
          plan_file: "tfplan"
          auto_approve: "true"

      - name: Verify Target Group Health Check Paths (Post-Apply)
        id: verify_health_checks
        if: inputs.action == 'apply' && steps.apply.outcome == 'success' && inputs.module_path == '04-ecs-fargate'
        continue-on-error: true
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          
          echo "::notice::Verifying target group health check paths after apply..."
          
          if [ -f "scripts/verify-target-group-health-checks.sh" ]; then
            chmod +x scripts/verify-target-group-health-checks.sh
            export TERRAFORM_DIR="$PLAN_DIR"
            export ENVIRONMENT="${{ inputs.environment }}"
            
            if scripts/verify-target-group-health-checks.sh; then
              echo "::notice::âœ“ All target group health check paths verified successfully"
              echo "verification_passed=true" >> $GITHUB_OUTPUT
            else
              echo "::warning::âš  State drift detected after apply. Target groups may not match configuration."
              echo "verification_passed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "::notice::Verification script not found, skipping..."
            echo "verification_passed=skipped" >> $GITHUB_OUTPUT
          fi

      - name: Cleanup partially created resources on apply failure
        if: inputs.action == 'apply' && steps.apply.outcome == 'failure' && inputs.environment != 'production'
        continue-on-error: true
        run: |
          echo "::error::Terraform apply failed. Attempting to destroy partially created resources..."
          
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          
          # Check if any resources exist in state
          # Terraform writes to state as resources are created, even if apply fails
          echo "::notice::Checking Terraform state for created resources..."
          STATE_LIST=$(terraform -chdir="$PLAN_DIR" state list 2>/dev/null || echo "")
          
          if [ -z "$STATE_LIST" ]; then
            echo "::notice::No resources found in Terraform state. No cleanup needed."
            exit 0
          fi
          
          # Show what resources are in state
          echo "::notice::Resources found in Terraform state (will be destroyed):"
          echo "$STATE_LIST" | while read -r resource; do
            echo "::notice::  - $resource"
          done
          
          # Try to refresh state to ensure it's up to date
          echo "::notice::Refreshing Terraform state to identify created resources..."
          terraform -chdir="$PLAN_DIR" refresh -no-color || echo "::warning::State refresh failed, proceeding with destroy attempt"
          
          # Attempt to destroy what was created
          # Use the same variable files as the apply
          DESTROY_ARGS="-auto-approve"
          if [ -n "${{ steps.build_var_files.outputs.var_files }}" ]; then
            for var_file in ${{ steps.build_var_files.outputs.var_files }}; do
              if [ -f "$PLAN_DIR/$var_file" ]; then
                DESTROY_ARGS="$DESTROY_ARGS -var-file=$var_file"
              fi
            done
          fi
          
          echo "::notice::Running terraform destroy to clean up partially created resources..."
          terraform -chdir="$PLAN_DIR" destroy $DESTROY_ARGS || {
            echo "::error::Destroy failed. Manual cleanup may be required."
            echo "::error::Please review the Terraform state and manually remove any partially created resources."
            echo "::error::You can run 'terraform state list' to see what resources are in state."
            exit 1
          }
          
          echo "::notice::Cleanup completed. Partially created resources have been destroyed."

      - name: Production apply failure notification
        if: inputs.action == 'apply' && steps.apply.outcome == 'failure' && inputs.environment == 'production'
        run: |
          echo "::error::Terraform apply failed in PRODUCTION environment."
          echo "::error::Automatic cleanup is disabled for production. Manual intervention required."
          echo "::error::Please review the Terraform state and decide on appropriate action:"
          echo "::error::  1. Review what resources were created before the failure"
          echo "::error::  2. Manually destroy partially created resources if needed"
          echo "::error::  3. Fix the issue and retry the deployment"
          exit 1

      - name: No Changes Detected
        if: inputs.action == 'apply' && steps.plan.outcome == 'success' && steps.plan_changes.outputs.has_changes == 'false'
        run: |
          echo "::notice::No changes to apply. Infrastructure is already up to date."
          echo "## âœ… No Changes Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The Terraform plan showed no changes. Your infrastructure matches the configuration." >> $GITHUB_STEP_SUMMARY

      - name: Plan Failed
        if: inputs.action == 'apply' && steps.plan.outcome == 'failure'
        run: |
          echo "::error::Terraform plan failed. Apply cannot proceed."
          exit 1

      - name: Terraform Destroy (Production Protection)
        if: inputs.action == 'destroy' && inputs.environment == 'production'
        run: |
          echo "::error::Destroy action is blocked for production environment for safety."
          exit 1

      - name: Build var files list for destroy
        id: build_var_files_destroy
        if: inputs.action == 'destroy' && inputs.environment != 'production'
        run: |
          VAR_FILES=""
          if [ "${{ steps.check_tfvars.outputs.tfvars_exists }}" == "true" ]; then
            VAR_FILES="terraform.tfvars"
          fi
          if [ "${{ steps.check_services_tfvars.outputs.services_tfvars_exists }}" == "true" ]; then
            if [ -n "$VAR_FILES" ]; then
              VAR_FILES="$VAR_FILES services.generated.tfvars"
            else
              VAR_FILES="services.generated.tfvars"
            fi
          fi
          echo "var_files=$VAR_FILES" >> $GITHUB_OUTPUT

      - name: Terraform Destroy
        if: inputs.action == 'destroy' && inputs.environment != 'production'
        run: |
          PLAN_DIR="DEVOPS/live/${{ inputs.environment }}/${{ inputs.module_path }}"
          DESTROY_ARGS="-auto-approve"
          if [ -n "${{ steps.build_var_files_destroy.outputs.var_files }}" ]; then
            for var_file in ${{ steps.build_var_files_destroy.outputs.var_files }}; do
              if [ -f "$PLAN_DIR/$var_file" ]; then
                DESTROY_ARGS="$DESTROY_ARGS -var-file=$var_file"
              fi
            done
          fi
          terraform -chdir="$PLAN_DIR" destroy $DESTROY_ARGS
