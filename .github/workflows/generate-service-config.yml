name: Validate Dhall Service Config

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'dhall/**'
      - 'applications/**'  # Also validate when app code changes (may affect service definitions)
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'dhall/**'
      - 'applications/**'  # Validate on PRs to catch issues early
  workflow_dispatch:

permissions:
  contents: read

jobs:
  validate-dhall-services:
    name: Validate Dhall Service Definitions
    runs-on: ubuntu-latest
    # REQUIRED: Validates Dhall service definitions for correctness before merge/deployment.
    # This workflow ensures:
    # - Type safety (catches errors before deployment)
    # - Service definitions match application structure
    # - No syntax or type errors in Dhall files
    #
    # Note: services.generated.json/tfvars are generated on-demand during deployment,
    # but this validation catches issues early in the development cycle.
    steps:
      - name: Checkout CI repository
        uses: actions/checkout@v4

      - name: Cache Dhall binaries
        id: cache-dhall
        uses: actions/cache@v4
        with:
          path: dhall/cache/binaries
          key: dhall-binaries-${{ runner.os }}-1.41.2
          restore-keys: |
            dhall-binaries-${{ runner.os }}-

      - name: Install Dhall and dhall-json (with fallback)
        run: |
          chmod +x scripts/install-dhall-with-fallback.sh
          scripts/install-dhall-with-fallback.sh

      - name: Type-check Dhall service definitions
        run: |
          echo "::notice::Type-checking dhall/services.dhall..."
          dhall type --file dhall/services.dhall
          echo "::notice::✓ Type-check passed"

      - name: Validate Dhall to JSON conversion
        run: |
          echo "::notice::Validating JSON conversion..."
          dhall-to-json --file dhall/services.dhall > /tmp/services.generated.json
          
          # Validate JSON structure
          if ! jq empty /tmp/services.generated.json 2>/dev/null; then
            echo "::error::Generated JSON is invalid"
            cat /tmp/services.generated.json
            exit 1
          fi
          
          SERVICE_COUNT=$(jq 'keys | length' /tmp/services.generated.json)
          echo "::notice::✓ JSON conversion successful"
          echo "::notice::✓ Found $SERVICE_COUNT service(s)"
          
          echo "::group::Service names"
          jq -r 'keys[]' /tmp/services.generated.json
          echo "::endgroup::"
          
          echo "::group::Generated JSON preview"
          cat /tmp/services.generated.json | jq '.' | head -50
          echo "::endgroup::"

      - name: Validate service definitions match application structure
        run: |
          echo "::notice::Validating service definitions match application structure..."
          
          # Extract all image_repo values from generated JSON
          IMAGE_REPOS=$(jq -r '.[].image_repo' /tmp/services.generated.json | sort -u)
          
          if [ -z "$IMAGE_REPOS" ]; then
            echo "::error::No image_repo values found in service definitions"
            exit 1
          fi
          
          echo "::group::Image repositories referenced in Dhall"
          echo "$IMAGE_REPOS"
          echo "::endgroup::"
          
          # Check if applications exist for each service
          MISSING_APPS=""
          for IMG_REPO in $IMAGE_REPOS; do
            # Extract app name from image repo (e.g., ghcr.io/owner/test-app-backend -> test-app)
            # Or handle different formats
            APP_NAME=$(echo "$IMG_REPO" | sed -E 's/.*\/([^/]+)-(backend|frontend|api)/\1/' || echo "$IMG_REPO" | sed -E 's/.*\/([^/]+)$/\1/')
            
            # Check if application directory exists
            if [ ! -d "applications/$APP_NAME" ]; then
              MISSING_APPS="${MISSING_APPS}${APP_NAME} "
              echo "::warning::Service references image '$IMG_REPO' but application directory 'applications/$APP_NAME' not found"
            else
              echo "::notice::✓ Application directory found for '$APP_NAME'"
            fi
          done
          
          if [ -n "$MISSING_APPS" ]; then
            echo "::error::Service definitions reference images for applications that don't exist:"
            echo "::error::Missing applications: $MISSING_APPS"
            echo "::error::"
            echo "::error::Either:"
            echo "::error::  1. Create the application directories: applications/$MISSING_APPS"
            echo "::error::  2. Fix the image_repo values in your Dhall service definitions"
            exit 1
          fi
          
          echo "::notice::✓ All service definitions reference existing applications"

      - name: Validate Docker image names match build expectations
        run: |
          echo "::notice::Validating Docker image names match build configuration..."
          
          # Extract image names (without registry prefix)
          IMAGE_NAMES=$(jq -r '.[].image_repo' /tmp/services.generated.json | sed 's|ghcr.io/[^/]*/||' | sort -u)
          
          echo "::group::Docker image names from service definitions"
          echo "$IMAGE_NAMES"
          echo "::endgroup::"
          
          # Check if these images would be built by the CI workflow
          # The CI workflow builds images based on applications/*/backend and applications/*/frontend
          EXPECTED_IMAGES=""
          for APP_DIR in applications/*/; do
            APP_NAME=$(basename "$APP_DIR")
            if [ -d "${APP_DIR}backend" ] && [ -f "${APP_DIR}backend/Dockerfile" ]; then
              EXPECTED_IMAGES="${EXPECTED_IMAGES}${APP_NAME}-backend "
            fi
            if [ -d "${APP_DIR}frontend" ] && [ -f "${APP_DIR}frontend/Dockerfile" ]; then
              EXPECTED_IMAGES="${EXPECTED_IMAGES}${APP_NAME}-frontend "
            fi
          done
          
          echo "::group::Expected Docker images (from application structure)"
          echo "$EXPECTED_IMAGES"
          echo "::endgroup::"
          
          # Check for mismatches (warnings, not errors - some images might be external)
          for IMG_NAME in $IMAGE_NAMES; do
            if ! echo "$EXPECTED_IMAGES" | grep -q "$IMG_NAME"; then
              echo "::warning::Service definition references image '$IMG_NAME' which may not be built by CI workflow"
              echo "::warning::Ensure this image exists in the container registry or is built elsewhere"
            fi
          done
          
          echo "::notice::✓ Docker image validation complete"

      - name: Summary
        if: success()
        run: |
          echo "## Dhall Validation Complete ✅" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**This workflow is REQUIRED** - it validates:" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Dhall syntax and type safety" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Service definitions match application structure" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Docker image references are valid" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note:** The actual \`services.generated.json\` file is generated on-demand during deployment." >> $GITHUB_STEP_SUMMARY
          echo "This validation catches issues early, before deployment." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Developer Flow:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Commit code + Dhall service definitions" >> $GITHUB_STEP_SUMMARY
          echo "2. Push to branch → This validation runs" >> $GITHUB_STEP_SUMMARY
          echo "3. CI builds Docker images" >> $GITHUB_STEP_SUMMARY
          echo "4. Deployment generates JSON on-demand and deploys" >> $GITHUB_STEP_SUMMARY
