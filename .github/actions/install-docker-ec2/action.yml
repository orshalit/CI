name: 'Install Docker on EC2'
description: 'Installs Docker and Docker Compose on EC2 instance via AWS SSM if not already present'
author: 'DevOps Team'

inputs:
  instance-id:
    description: 'EC2 instance ID'
    required: true
  region:
    description: 'AWS region'
    required: true
  timeout:
    description: 'Timeout in seconds for installation'
    required: false
    default: '600'

outputs:
  command-id:
    description: 'SSM command ID for the Docker installation (last command)'
    value: ${{ steps.install-compose.outputs.command-id || steps.install-docker.outputs.command-id }}
  already-installed:
    description: 'Whether Docker was already installed'
    value: ${{ steps.install-docker.outputs.already-installed }}

runs:
  using: 'composite'
  steps:
    # =====================================================================
    # Step 1: Install Docker
    # =====================================================================
    - name: Install Docker
      id: install-docker
      shell: bash
      run: |
        INSTANCE_ID="${{ inputs.instance-id }}"
        INSTANCE_REGION="${{ inputs.region }}"
        TIMEOUT="${{ inputs.timeout }}"
        
        echo "=== Installing Docker ==="
        echo "Instance: ${INSTANCE_ID}"
        echo "Region: ${INSTANCE_REGION}"
        echo "Timeout: ${TIMEOUT}s"
        echo ""
        
        # Create Docker installation script
        SCRIPT_FILE=$(mktemp)
        printf '%s\n' \
          'set -e' \
          'echo "=== Detecting OS ==="' \
          'if [ -f /etc/os-release ]; then' \
          '  . /etc/os-release' \
          '  OS=$ID' \
          '  VERSION=$VERSION_ID' \
          '  echo "OS: $OS $VERSION"' \
          'else' \
          '  echo "ERROR: Cannot detect OS"' \
          '  exit 1' \
          'fi' \
          'echo ""' \
          'echo "=== Checking Docker ==="' \
          'if command -v docker &> /dev/null; then' \
          '  DOCKER_VERSION=$(docker --version)' \
          '  echo "Docker already installed: $DOCKER_VERSION"' \
          '  DOCKER_INSTALLED=true' \
          'else' \
          '  echo "Docker not found, installing..."' \
          '  DOCKER_INSTALLED=false' \
          'fi' \
          'if [ "$DOCKER_INSTALLED" = "false" ]; then' \
          '  echo ""' \
          '  echo "=== Installing Docker ==="' \
          '  echo "Starting Docker installation process..."' \
          '  if [ "$OS" = "ubuntu" ] || [ "$OS" = "debian" ]; then' \
          '    echo "Updating package lists..."' \
          '    sudo apt-get update -y' \
          '    echo "Installing prerequisites..."' \
          '    sudo apt-get install -y ca-certificates curl gnupg lsb-release' \
          '    echo "Setting up Docker repository..."' \
          '    sudo install -m 0755 -d /etc/apt/keyrings' \
          '    curl -fsSL https://download.docker.com/linux/$OS/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg' \
          '    sudo chmod a+r /etc/apt/keyrings/docker.gpg' \
          '    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$OS $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null' \
          '    echo "Updating package lists with Docker repository..."' \
          '    sudo apt-get update -y' \
          '    echo "Installing Docker packages..."' \
          '    sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin' \
          '  elif [ "$OS" = "amzn" ] || [ "$OS" = "amazon" ]; then' \
          '    echo "Updating system packages..."' \
          '    sudo yum update -y' \
          '    echo "Installing Docker..."' \
          '    sudo yum install -y docker' \
          '    echo "Starting Docker service..."' \
          '    sudo systemctl start docker' \
          '    sudo systemctl enable docker' \
          '  elif [ "$OS" = "rhel" ] || [ "$OS" = "centos" ]; then' \
          '    echo "Installing yum-utils..."' \
          '    sudo yum install -y yum-utils' \
          '    echo "Adding Docker repository..."' \
          '    sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo' \
          '    echo "Installing Docker packages..."' \
          '    sudo yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin' \
          '    echo "Starting Docker service..."' \
          '    sudo systemctl start docker' \
          '    sudo systemctl enable docker' \
          '  else' \
          '    echo "ERROR: Unsupported OS: $OS"' \
          '    exit 1' \
          '  fi' \
          '  echo "Adding user to docker group..."' \
          '  sudo usermod -aG docker $USER || true' \
          '  echo "Verifying Docker installation..."' \
          '  sudo docker --version || (echo "ERROR: Docker installation failed" && exit 1)' \
          '  echo "Docker installed successfully"' \
          '  echo "NOTE: User added to docker group. Docker commands will work in new sessions."' \
          'else' \
          '  echo "Docker is already installed, skipping installation."' \
          'fi' \
          'echo ""' \
          'echo "=== Docker Verification ==="' \
          'sudo docker --version' \
          'echo "Docker is ready"' \
          > "$SCRIPT_FILE"
        
        # Use jq to construct properly escaped JSON for SSM
        COMMANDS_JSON=$(jq -n --rawfile script "$SCRIPT_FILE" '{"commands": [$script]}')
        rm -f "$SCRIPT_FILE"
        
        # Send Docker installation command via SSM
        COMMAND_ID=$(aws ssm send-command \
          --region "${INSTANCE_REGION}" \
          --instance-ids "${INSTANCE_ID}" \
          --document-name "AWS-RunShellScript" \
          --comment "Install Docker on EC2 instance" \
          --parameters "${COMMANDS_JSON}" \
          --timeout-seconds ${TIMEOUT} \
          --query 'Command.CommandId' \
          --output text)
        
        if [ -z "$COMMAND_ID" ]; then
          echo "::error::Failed to send SSM command for Docker installation"
          exit 1
        fi
        
        echo "docker-command-id=${COMMAND_ID}" >> $GITHUB_OUTPUT
        echo "command-id=${COMMAND_ID}" >> $GITHUB_OUTPUT
        echo "::notice::Docker installation command sent: ${COMMAND_ID}"
        
        # Wait for Docker installation to complete
        echo "Waiting for Docker installation..."
        MAX_WAIT=${TIMEOUT}
        ELAPSED=0
        LAST_OUTPUT_CHECK=0
        while [ ${ELAPSED} -lt ${MAX_WAIT} ]; do
          STATUS=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" = "Success" ]; then
            echo "::notice::Docker installation completed successfully"
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            echo "::error::Docker installation failed with status: ${STATUS}"
            echo ""
            echo "=== Error Details ==="
            ERROR_OUTPUT=$(aws ssm get-command-invocation \
              --region "${INSTANCE_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query 'StandardErrorContent' \
              --output text 2>/dev/null || echo "No error details available")
            echo "Error output: ${ERROR_OUTPUT}"
            echo ""
            STDOUT=$(aws ssm get-command-invocation \
              --region "${INSTANCE_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query 'StandardOutputContent' \
              --output text 2>/dev/null || echo "No output available")
            echo "Standard output: ${STDOUT}"
            echo ""
            echo "::error::Troubleshooting: Check instance resources, network connectivity, and package repository access"
            exit 1
          fi
          
          # Retrieve and display output every 60 seconds
          if [ $((ELAPSED - LAST_OUTPUT_CHECK)) -ge 60 ]; then
            PARTIAL_OUTPUT=$(aws ssm get-command-invocation \
              --region "${INSTANCE_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query 'StandardOutputContent' \
              --output text 2>/dev/null || echo "")
            if [ -n "$PARTIAL_OUTPUT" ]; then
              echo "=== Current Installation Progress ==="
              echo "$PARTIAL_OUTPUT"
              echo ""
            fi
            LAST_OUTPUT_CHECK=${ELAPSED}
          fi
          
          sleep 5
          ELAPSED=$((ELAPSED + 5))
          # Progress update every 15 seconds
          if [ $((ELAPSED % 15)) -eq 0 ]; then
            echo "Still installing Docker... (${ELAPSED}s / ${MAX_WAIT}s)"
          fi
        done
        
        if [ "$STATUS" != "Success" ]; then
          echo "::error::Docker installation timed out or failed after ${ELAPSED}s"
          echo ""
          echo "=== Final Command Status ==="
          FINAL_STATUS=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query 'Status' \
            --output text 2>/dev/null || echo "Unknown")
          echo "Status: ${FINAL_STATUS}"
          echo ""
          FINAL_OUTPUT=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query 'StandardOutputContent' \
            --output text 2>/dev/null || echo "No output available")
          echo "=== Final Output ==="
          echo "${FINAL_OUTPUT}"
          echo ""
          FINAL_ERROR=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query 'StandardErrorContent' \
            --output text 2>/dev/null || echo "No error output available")
          echo "=== Final Error Output ==="
          echo "${FINAL_ERROR}"
          echo ""
          echo "::error::Troubleshooting: Check instance CPU/memory, network connectivity, and package repository access. Timeout may need to be increased for slow instances."
          exit 1
        fi
        
        # Show Docker installation output
        INSTALL_OUTPUT=$(aws ssm get-command-invocation \
          --region "${INSTANCE_REGION}" \
          --command-id "${COMMAND_ID}" \
          --instance-id "${INSTANCE_ID}" \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "=== Docker Installation Output ==="
        echo "$INSTALL_OUTPUT"
        
        # Check if Docker was already installed
        if echo "$INSTALL_OUTPUT" | grep -q "Docker already installed"; then
          echo "already-installed=true" >> $GITHUB_OUTPUT
        else
          echo "already-installed=false" >> $GITHUB_OUTPUT
        fi

    # =====================================================================
    # Step 2: Install Docker Compose
    # =====================================================================
    - name: Install Docker Compose
      id: install-compose
      shell: bash
      run: |
        INSTANCE_ID="${{ inputs.instance-id }}"
        INSTANCE_REGION="${{ inputs.region }}"
        TIMEOUT="${{ inputs.timeout }}"
        
        echo "=== Installing Docker Compose ==="
        echo "Instance: ${INSTANCE_ID}"
        echo "Region: ${INSTANCE_REGION}"
        echo "Timeout: ${TIMEOUT}s"
        echo ""
        
        # Create Docker Compose installation script
        SCRIPT_FILE=$(mktemp)
        printf '%s\n' \
          'set -e' \
          'echo "=== Checking Docker Compose ==="' \
          'if command -v docker-compose &> /dev/null || docker compose version &> /dev/null 2>&1; then' \
          '  if docker compose version &> /dev/null 2>&1; then' \
          '    COMPOSE_VERSION=$(docker compose version)' \
          '    echo "Docker Compose (plugin) already installed: $COMPOSE_VERSION"' \
          '  else' \
          '    COMPOSE_VERSION=$(docker-compose --version)' \
          '    echo "Docker Compose (standalone) already installed: $COMPOSE_VERSION"' \
          '  fi' \
          '  COMPOSE_INSTALLED=true' \
          'else' \
          '  echo "Docker Compose not found, installing..."' \
          '  COMPOSE_INSTALLED=false' \
          'fi' \
          'if [ "$COMPOSE_INSTALLED" = "false" ]; then' \
          '  echo ""' \
          '  echo "=== Installing Docker Compose ==="' \
          '  echo "Checking if Docker Compose plugin is available..."' \
          '  if docker compose version &> /dev/null 2>&1; then' \
          '    echo "Docker Compose plugin is available (installed with Docker)"' \
          '  else' \
          '    echo "Installing standalone Docker Compose..."' \
          '    COMPOSE_VERSION="v2.24.0"' \
          '    echo "Downloading Docker Compose ${COMPOSE_VERSION}..."' \
          '    sudo curl -L "https://github.com/docker/compose/releases/download/$COMPOSE_VERSION/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose' \
          '    echo "Setting executable permissions..."' \
          '    sudo chmod +x /usr/local/bin/docker-compose' \
          '    echo "Verifying Docker Compose installation..."' \
          '    docker-compose --version || (echo "ERROR: Docker Compose installation failed" && exit 1)' \
          '    echo "Docker Compose installed successfully"' \
          '  fi' \
          'else' \
          '  echo "Docker Compose is already installed, skipping installation."' \
          'fi' \
          'echo ""' \
          'echo "=== Docker Compose Verification ==="' \
          'if sudo docker compose version &> /dev/null 2>&1; then' \
          '  sudo docker compose version' \
          '  echo "Using Docker Compose plugin"' \
          'elif command -v docker-compose &> /dev/null && sudo docker-compose --version &> /dev/null 2>&1; then' \
          '  sudo docker-compose --version' \
          '  echo "Using standalone Docker Compose"' \
          'else' \
          '  echo "ERROR: Docker Compose not available"' \
          '  exit 1' \
          'fi' \
          'echo "Docker Compose is ready"' \
          > "$SCRIPT_FILE"
        
        # Use jq to construct properly escaped JSON for SSM
        COMMANDS_JSON=$(jq -n --rawfile script "$SCRIPT_FILE" '{"commands": [$script]}')
        rm -f "$SCRIPT_FILE"
        
        # Send Docker Compose installation command via SSM
        COMMAND_ID=$(aws ssm send-command \
          --region "${INSTANCE_REGION}" \
          --instance-ids "${INSTANCE_ID}" \
          --document-name "AWS-RunShellScript" \
          --comment "Install Docker Compose on EC2 instance" \
          --parameters "${COMMANDS_JSON}" \
          --timeout-seconds ${TIMEOUT} \
          --query 'Command.CommandId' \
          --output text)
        
        if [ -z "$COMMAND_ID" ]; then
          echo "::error::Failed to send SSM command for Docker Compose installation"
          exit 1
        fi
        
        echo "compose-command-id=${COMMAND_ID}" >> $GITHUB_OUTPUT
        echo "command-id=${COMMAND_ID}" >> $GITHUB_OUTPUT
        echo "::notice::Docker Compose installation command sent: ${COMMAND_ID}"
        
        # Wait for Docker Compose installation to complete
        echo "Waiting for Docker Compose installation..."
        MAX_WAIT=${TIMEOUT}
        ELAPSED=0
        LAST_OUTPUT_CHECK=0
        while [ ${ELAPSED} -lt ${MAX_WAIT} ]; do
          STATUS=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query 'Status' \
            --output text 2>/dev/null || echo "Pending")
          
          if [ "$STATUS" = "Success" ]; then
            echo "::notice::Docker Compose installation completed successfully"
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            echo "::error::Docker Compose installation failed with status: ${STATUS}"
            echo ""
            echo "=== Error Details ==="
            ERROR_OUTPUT=$(aws ssm get-command-invocation \
              --region "${INSTANCE_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query 'StandardErrorContent' \
              --output text 2>/dev/null || echo "No error details available")
            echo "Error output: ${ERROR_OUTPUT}"
            echo ""
            STDOUT=$(aws ssm get-command-invocation \
              --region "${INSTANCE_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query 'StandardOutputContent' \
              --output text 2>/dev/null || echo "No output available")
            echo "Standard output: ${STDOUT}"
            echo ""
            echo "::error::Troubleshooting: Check network connectivity and GitHub releases access"
            exit 1
          fi
          
          # Retrieve and display output every 60 seconds
          if [ $((ELAPSED - LAST_OUTPUT_CHECK)) -ge 60 ]; then
            PARTIAL_OUTPUT=$(aws ssm get-command-invocation \
              --region "${INSTANCE_REGION}" \
              --command-id "${COMMAND_ID}" \
              --instance-id "${INSTANCE_ID}" \
              --query 'StandardOutputContent' \
              --output text 2>/dev/null || echo "")
            if [ -n "$PARTIAL_OUTPUT" ]; then
              echo "=== Current Installation Progress ==="
              echo "$PARTIAL_OUTPUT"
              echo ""
            fi
            LAST_OUTPUT_CHECK=${ELAPSED}
          fi
          
          sleep 5
          ELAPSED=$((ELAPSED + 5))
          # Progress update every 15 seconds
          if [ $((ELAPSED % 15)) -eq 0 ]; then
            echo "Still installing Docker Compose... (${ELAPSED}s / ${MAX_WAIT}s)"
          fi
        done
        
        if [ "$STATUS" != "Success" ]; then
          echo "::error::Docker Compose installation timed out or failed after ${ELAPSED}s"
          echo ""
          echo "=== Final Command Status ==="
          FINAL_STATUS=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query 'Status' \
            --output text 2>/dev/null || echo "Unknown")
          echo "Status: ${FINAL_STATUS}"
          echo ""
          FINAL_OUTPUT=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query 'StandardOutputContent' \
            --output text 2>/dev/null || echo "No output available")
          echo "=== Final Output ==="
          echo "${FINAL_OUTPUT}"
          echo ""
          FINAL_ERROR=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query 'StandardErrorContent' \
            --output text 2>/dev/null || echo "No error output available")
          echo "=== Final Error Output ==="
          echo "${FINAL_ERROR}"
          echo ""
          echo "::error::Troubleshooting: Check network connectivity and GitHub releases access. Timeout may need to be increased for slow network connections."
          exit 1
        fi
        
        # Show Docker Compose installation output
        INSTALL_OUTPUT=$(aws ssm get-command-invocation \
          --region "${INSTANCE_REGION}" \
          --command-id "${COMMAND_ID}" \
          --instance-id "${INSTANCE_ID}" \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "=== Docker Compose Installation Output ==="
        echo "$INSTALL_OUTPUT"
        echo ""
        echo "=== Installation Complete ==="
        echo "Docker and Docker Compose are ready"
