name: 'Install Docker on EC2'
description: 'Installs Docker and Docker Compose on EC2 instance via AWS SSM if not already present'
author: 'DevOps Team'

inputs:
  instance-id:
    description: 'EC2 instance ID'
    required: true
  region:
    description: 'AWS region'
    required: true
  timeout:
    description: 'Timeout in seconds for installation'
    required: false
    default: '600'

outputs:
  command-id:
    description: 'SSM command ID for the Docker installation (last command)'
    value: ${{ steps.install-compose.outputs.command-id || steps.install-docker.outputs.command-id }}
  already-installed:
    description: 'Whether Docker was already installed'
    value: ${{ steps.install-docker.outputs.already-installed }}

runs:
  using: 'composite'
  steps:
    # =====================================================================
    # Step 1: Install Docker
    # =====================================================================
    - name: Install Docker
      id: install-docker
      shell: bash
      run: |
        INSTANCE_ID="${{ inputs.instance-id }}"
        INSTANCE_REGION="${{ inputs.region }}"
        TIMEOUT="${{ inputs.timeout }}"
        
        echo "=== Installing Docker ==="
        echo "Instance: ${INSTANCE_ID}"
        echo "Region: ${INSTANCE_REGION}"
        echo "Timeout: ${TIMEOUT}s"
        echo ""
        
        # Create Docker installation script
        SCRIPT_FILE=$(mktemp)
        printf '%s\n' \
          'set -e' \
          'echo "=== Detecting OS ==="' \
          'if [ -f /etc/os-release ]; then' \
          '  . /etc/os-release' \
          '  OS=$ID' \
          '  VERSION=$VERSION_ID' \
          '  echo "OS: $OS $VERSION"' \
          'else' \
          '  echo "ERROR: Cannot detect OS"' \
          '  exit 1' \
          'fi' \
          'echo ""' \
          'echo "=== Checking Docker ==="' \
          'if command -v docker &> /dev/null; then' \
          '  DOCKER_VERSION=$(docker --version)' \
          '  echo "Docker already installed: $DOCKER_VERSION"' \
          '  DOCKER_INSTALLED=true' \
          'else' \
          '  echo "Docker not found, installing..."' \
          '  DOCKER_INSTALLED=false' \
          'fi' \
          'if [ "$DOCKER_INSTALLED" = "false" ]; then' \
          '  echo ""' \
          '  echo "=== Installing Docker ==="' \
          '  echo "Starting Docker installation process..."' \
          '  if [ "$OS" = "ubuntu" ] || [ "$OS" = "debian" ]; then' \
          '    echo "Updating package lists..."' \
          '    sudo apt-get update -y' \
          '    echo "Installing prerequisites..."' \
          '    sudo apt-get install -y ca-certificates curl gnupg lsb-release' \
          '    echo "Setting up Docker repository..."' \
          '    sudo install -m 0755 -d /etc/apt/keyrings' \
          '    curl -fsSL https://download.docker.com/linux/$OS/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg' \
          '    sudo chmod a+r /etc/apt/keyrings/docker.gpg' \
          '    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/$OS $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null' \
          '    echo "Updating package lists with Docker repository..."' \
          '    sudo apt-get update -y' \
          '    echo "Installing Docker packages..."' \
          '    sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin' \
          '  elif [ "$OS" = "amzn" ] || [ "$OS" = "amazon" ]; then' \
          '    echo "Updating system packages..."' \
          '    sudo yum update -y' \
          '    echo "Installing Docker..."' \
          '    sudo yum install -y docker' \
          '    echo "Starting Docker service..."' \
          '    sudo systemctl start docker' \
          '    sudo systemctl enable docker' \
          '  elif [ "$OS" = "rhel" ] || [ "$OS" = "centos" ]; then' \
          '    echo "Installing yum-utils..."' \
          '    sudo yum install -y yum-utils' \
          '    echo "Adding Docker repository..."' \
          '    sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo' \
          '    echo "Installing Docker packages..."' \
          '    sudo yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin' \
          '    echo "Starting Docker service..."' \
          '    sudo systemctl start docker' \
          '    sudo systemctl enable docker' \
          '  else' \
          '    echo "ERROR: Unsupported OS: $OS"' \
          '    exit 1' \
          '  fi' \
          '  echo "Adding user to docker group..."' \
          '  sudo usermod -aG docker $USER || true' \
          '  echo "Verifying Docker installation..."' \
          '  sudo docker --version || (echo "ERROR: Docker installation failed" && exit 1)' \
          '  echo "Docker installed successfully"' \
          '  echo "NOTE: User added to docker group. Docker commands will work in new sessions."' \
          'else' \
          '  echo "Docker is already installed, skipping installation."' \
          'fi' \
          'echo ""' \
          'echo "=== Docker Verification ==="' \
          'sudo docker --version' \
          'echo "Docker is ready"' \
          > "$SCRIPT_FILE"
        
        # Use jq to construct properly escaped JSON for SSM
        COMMANDS_JSON=$(jq -n --rawfile script "$SCRIPT_FILE" '{"commands": [$script]}')
        rm -f "$SCRIPT_FILE"
        
        # Send Docker installation command via SSM
        COMMAND_ID=$(aws ssm send-command \
          --region "${INSTANCE_REGION}" \
          --instance-ids "${INSTANCE_ID}" \
          --document-name "AWS-RunShellScript" \
          --comment "Install Docker on EC2 instance" \
          --parameters "${COMMANDS_JSON}" \
          --timeout-seconds ${TIMEOUT} \
          --query 'Command.CommandId' \
          --output text)
        
        if [ -z "$COMMAND_ID" ]; then
          echo "::error::Failed to send SSM command for Docker installation"
          exit 1
        fi
        
        echo "docker-command-id=${COMMAND_ID}" >> $GITHUB_OUTPUT
        echo "command-id=${COMMAND_ID}" >> $GITHUB_OUTPUT
        echo "::notice::Docker installation command sent: ${COMMAND_ID}"
        
        # Wait a few seconds for the command to be registered in SSM before polling
        echo "Waiting 5 seconds for command to be registered in SSM..."
        sleep 5
        
        # Wait for Docker installation to complete
        echo "Waiting for Docker installation..."
        echo "Checking SSM command status every 5 seconds..."
        MAX_WAIT=${TIMEOUT}
        ELAPSED=5  # Start at 5 since we already waited
        LAST_OUTPUT_CHECK=0
        LAST_STATUS=""
        RETRY_COUNT=0
        
        # Check if jq is available
        if ! command -v jq &> /dev/null; then
          echo "::warning::jq not found, using grep/awk for JSON parsing"
          USE_JQ=false
        else
          USE_JQ=true
        fi
        
        while [ ${ELAPSED} -lt ${MAX_WAIT} ]; do
          # Get full command invocation details with error capture
          set +e  # Temporarily disable exit on error to capture exit code
          COMMAND_INFO=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            2>&1)
          AWS_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Check for errors
          if [ $AWS_EXIT_CODE -ne 0 ]; then
            STATUS="ErrorRetrievingStatus"
            RETRY_COUNT=$((RETRY_COUNT + 1))
            
            # Show the actual AWS error on first failure and every 30 seconds
            if [ $RETRY_COUNT -eq 1 ] || [ $((ELAPSED % 30)) -eq 0 ]; then
              echo "::warning::Failed to retrieve SSM command status at ${ELAPSED}s"
              echo "AWS CLI exit code: ${AWS_EXIT_CODE}"
              echo "Error output: ${COMMAND_INFO}"
              if echo "$COMMAND_INFO" | grep -q "AccessDenied\|UnauthorizedOperation"; then
                echo "::error::IAM Permission Issue: The GitHub Actions role may not have 'ssm:GetCommandInvocation' permission"
                echo "::error::Required resource ARN: arn:aws:ssm:${INSTANCE_REGION}:*:command/*"
                echo "::error::Please apply the Terraform fix in DEVOPS/modules/backend/github-oidc/main.tf"
              fi
            fi
          elif [ -z "$COMMAND_INFO" ]; then
            STATUS="ErrorRetrievingStatus"
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -eq 1 ] || [ $((ELAPSED % 30)) -eq 0 ]; then
              echo "::warning::Failed to retrieve SSM command status at ${ELAPSED}s (empty response)"
            fi
          else
            # Check if response contains error message (without causing script to exit)
            set +e
            echo "$COMMAND_INFO" | grep -q "^An error occurred" 2>/dev/null
            HAS_ERROR=$?
            set -e
            
            if [ $HAS_ERROR -eq 0 ]; then
              STATUS="ErrorRetrievingStatus"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -eq 1 ] || [ $((ELAPSED % 30)) -eq 0 ]; then
                echo "::warning::Failed to retrieve SSM command status at ${ELAPSED}s (error in response)"
                echo "Response: ${COMMAND_INFO}"
              fi
            else
              # Parse JSON response
              set +e  # Disable exit on error for parsing
              if [ "$USE_JQ" = "true" ]; then
                STATUS=$(echo "$COMMAND_INFO" | jq -r '.Status // "Unknown"' 2>/dev/null || echo "Unknown")
                RESPONSE_CODE=$(echo "$COMMAND_INFO" | jq -r '.ResponseCode // "N/A"' 2>/dev/null || echo "N/A")
                EXECUTION_ELAPSED=$(echo "$COMMAND_INFO" | jq -r '.ExecutionElapsedTime // "N/A"' 2>/dev/null || echo "N/A")
              else
                # Fallback parsing without jq
                STATUS=$(echo "$COMMAND_INFO" | grep -o '"Status"[[:space:]]*:[[:space:]]*"[^"]*"' 2>/dev/null | cut -d'"' -f4 || echo "Unknown")
                RESPONSE_CODE=$(echo "$COMMAND_INFO" | grep -o '"ResponseCode"[[:space:]]*:[[:space:]]*[0-9]*' 2>/dev/null | cut -d':' -f2 | tr -d ' ' || echo "N/A")
                EXECUTION_ELAPSED=$(echo "$COMMAND_INFO" | grep -o '"ExecutionElapsedTime"[[:space:]]*:[[:space:]]*[0-9]*' 2>/dev/null | cut -d':' -f2 | tr -d ' ' || echo "N/A")
              fi
              set -e  # Re-enable exit on error
              RETRY_COUNT=0  # Reset retry count on successful retrieval
            fi
          fi
          
          # Show status change or progress update
          if [ "$STATUS" != "$LAST_STATUS" ] || [ $((ELAPSED % 15)) -eq 0 ]; then
            if [ "$STATUS" != "$LAST_STATUS" ]; then
              echo "::notice::SSM Command Status changed: ${LAST_STATUS:-Initial} -> ${STATUS}"
            fi
            echo "[${ELAPSED}s] Status: ${STATUS} | ResponseCode: ${RESPONSE_CODE} | SSM Execution Time: ${EXECUTION_ELAPSED}s"
            LAST_STATUS="$STATUS"
          fi
          
          if [ "$STATUS" = "Success" ]; then
            echo "::notice::Docker installation completed successfully"
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            echo "::error::Docker installation failed with status: ${STATUS}"
            echo ""
            echo "=== Error Details ==="
            ERROR_OUTPUT=$(echo "$COMMAND_INFO" | jq -r '.StandardErrorContent // "No error details available"' 2>/dev/null || echo "No error details available")
            echo "Error output: ${ERROR_OUTPUT}"
            echo ""
            STDOUT=$(echo "$COMMAND_INFO" | jq -r '.StandardOutputContent // "No output available"' 2>/dev/null || echo "No output available")
            echo "Standard output: ${STDOUT}"
            echo ""
            echo "Response Code: ${RESPONSE_CODE}"
            echo "Execution Elapsed Time: ${EXECUTION_ELAPSED}s"
            echo ""
            echo "::error::Troubleshooting: Check instance resources, network connectivity, and package repository access"
            exit 1
          fi
          
          # Retrieve and display output every 30 seconds (more frequent)
          if [ $((ELAPSED - LAST_OUTPUT_CHECK)) -ge 30 ]; then
            if [ -n "$COMMAND_INFO" ]; then
              PARTIAL_OUTPUT=$(echo "$COMMAND_INFO" | jq -r '.StandardOutputContent // ""' 2>/dev/null || echo "")
              if [ -n "$PARTIAL_OUTPUT" ] && [ "$PARTIAL_OUTPUT" != "null" ]; then
                echo ""
                echo "=== Current Installation Progress (at ${ELAPSED}s) ==="
                echo "$PARTIAL_OUTPUT"
                echo ""
              else
                echo "[${ELAPSED}s] No output available yet (command may still be starting)"
              fi
            else
              echo "[${ELAPSED}s] Unable to retrieve command information"
            fi
            LAST_OUTPUT_CHECK=${ELAPSED}
          fi
          
          sleep 5
          ELAPSED=$((ELAPSED + 5))
        done
        
        if [ "$STATUS" != "Success" ]; then
          echo "::error::Docker installation timed out or failed after ${ELAPSED}s"
          echo ""
          echo "=== Final Command Status Check ==="
          FINAL_COMMAND_INFO=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            2>/dev/null || echo "")
          
          if [ -z "$FINAL_COMMAND_INFO" ]; then
            echo "ERROR: Unable to retrieve final command status from SSM"
            echo "This may indicate:"
            echo "  - SSM service is unavailable"
            echo "  - Command ID is invalid: ${COMMAND_ID}"
            echo "  - Instance is not accessible: ${INSTANCE_ID}"
            echo "  - IAM permissions issue"
          else
            FINAL_STATUS=$(echo "$FINAL_COMMAND_INFO" | jq -r '.Status // "Unknown"' 2>/dev/null || echo "Unknown")
            FINAL_RESPONSE_CODE=$(echo "$FINAL_COMMAND_INFO" | jq -r '.ResponseCode // "N/A"' 2>/dev/null || echo "N/A")
            FINAL_EXECUTION_TIME=$(echo "$FINAL_COMMAND_INFO" | jq -r '.ExecutionElapsedTime // "N/A"' 2>/dev/null || echo "N/A")
            FINAL_OUTPUT=$(echo "$FINAL_COMMAND_INFO" | jq -r '.StandardOutputContent // "No output available"' 2>/dev/null || echo "No output available")
            FINAL_ERROR=$(echo "$FINAL_COMMAND_INFO" | jq -r '.StandardErrorContent // "No error output available"' 2>/dev/null || echo "No error output available")
            
            echo "Status: ${FINAL_STATUS}"
            echo "Response Code: ${FINAL_RESPONSE_CODE}"
            echo "SSM Execution Time: ${FINAL_EXECUTION_TIME}s"
            echo "Polling Time: ${ELAPSED}s"
            echo ""
            echo "=== Final Output ==="
            if [ "$FINAL_OUTPUT" != "No output available" ] && [ "$FINAL_OUTPUT" != "null" ] && [ -n "$FINAL_OUTPUT" ]; then
              echo "$FINAL_OUTPUT"
            else
              echo "No output available (command may not have started or SSM is not returning output)"
            fi
            echo ""
            echo "=== Final Error Output ==="
            if [ "$FINAL_ERROR" != "No error output available" ] && [ "$FINAL_ERROR" != "null" ] && [ -n "$FINAL_ERROR" ]; then
              echo "$FINAL_ERROR"
            else
              echo "No error output available"
            fi
            echo ""
            echo "=== Full Command Details (JSON) ==="
            echo "$FINAL_COMMAND_INFO" | jq '.' 2>/dev/null || echo "$FINAL_COMMAND_INFO"
          fi
          echo ""
          echo "::error::Troubleshooting: Check instance CPU/memory, network connectivity, and package repository access. Timeout may need to be increased for slow instances."
          exit 1
        fi
        
        # Show Docker installation output
        INSTALL_OUTPUT=$(aws ssm get-command-invocation \
          --region "${INSTANCE_REGION}" \
          --command-id "${COMMAND_ID}" \
          --instance-id "${INSTANCE_ID}" \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "=== Docker Installation Output ==="
        echo "$INSTALL_OUTPUT"
        
        # Check if Docker was already installed
        if echo "$INSTALL_OUTPUT" | grep -q "Docker already installed"; then
          echo "already-installed=true" >> $GITHUB_OUTPUT
        else
          echo "already-installed=false" >> $GITHUB_OUTPUT
        fi

    # =====================================================================
    # Step 2: Install Docker Compose
    # =====================================================================
    - name: Install Docker Compose
      id: install-compose
      shell: bash
      run: |
        INSTANCE_ID="${{ inputs.instance-id }}"
        INSTANCE_REGION="${{ inputs.region }}"
        TIMEOUT="${{ inputs.timeout }}"
        
        echo "=== Installing Docker Compose ==="
        echo "Instance: ${INSTANCE_ID}"
        echo "Region: ${INSTANCE_REGION}"
        echo "Timeout: ${TIMEOUT}s"
        echo ""
        
        # Create Docker Compose installation script
        SCRIPT_FILE=$(mktemp)
        printf '%s\n' \
          'set -e' \
          'echo "=== Checking Docker Compose ==="' \
          'if command -v docker-compose &> /dev/null || docker compose version &> /dev/null 2>&1; then' \
          '  if docker compose version &> /dev/null 2>&1; then' \
          '    COMPOSE_VERSION=$(docker compose version)' \
          '    echo "Docker Compose (plugin) already installed: $COMPOSE_VERSION"' \
          '  else' \
          '    COMPOSE_VERSION=$(docker-compose --version)' \
          '    echo "Docker Compose (standalone) already installed: $COMPOSE_VERSION"' \
          '  fi' \
          '  COMPOSE_INSTALLED=true' \
          'else' \
          '  echo "Docker Compose not found, installing..."' \
          '  COMPOSE_INSTALLED=false' \
          'fi' \
          'if [ "$COMPOSE_INSTALLED" = "false" ]; then' \
          '  echo ""' \
          '  echo "=== Installing Docker Compose ==="' \
          '  echo "Checking if Docker Compose plugin is available..."' \
          '  if docker compose version &> /dev/null 2>&1; then' \
          '    echo "Docker Compose plugin is available (installed with Docker)"' \
          '  else' \
          '    echo "Installing standalone Docker Compose..."' \
          '    COMPOSE_VERSION="v2.24.0"' \
          '    echo "Downloading Docker Compose ${COMPOSE_VERSION}..."' \
          '    sudo curl -L "https://github.com/docker/compose/releases/download/$COMPOSE_VERSION/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose' \
          '    echo "Setting executable permissions..."' \
          '    sudo chmod +x /usr/local/bin/docker-compose' \
          '    echo "Verifying Docker Compose installation..."' \
          '    docker-compose --version || (echo "ERROR: Docker Compose installation failed" && exit 1)' \
          '    echo "Docker Compose installed successfully"' \
          '  fi' \
          'else' \
          '  echo "Docker Compose is already installed, skipping installation."' \
          'fi' \
          'echo ""' \
          'echo "=== Docker Compose Verification ==="' \
          'if sudo docker compose version &> /dev/null 2>&1; then' \
          '  sudo docker compose version' \
          '  echo "Using Docker Compose plugin"' \
          'elif command -v docker-compose &> /dev/null && sudo docker-compose --version &> /dev/null 2>&1; then' \
          '  sudo docker-compose --version' \
          '  echo "Using standalone Docker Compose"' \
          'else' \
          '  echo "ERROR: Docker Compose not available"' \
          '  exit 1' \
          'fi' \
          'echo "Docker Compose is ready"' \
          > "$SCRIPT_FILE"
        
        # Use jq to construct properly escaped JSON for SSM
        COMMANDS_JSON=$(jq -n --rawfile script "$SCRIPT_FILE" '{"commands": [$script]}')
        rm -f "$SCRIPT_FILE"
        
        # Send Docker Compose installation command via SSM
        COMMAND_ID=$(aws ssm send-command \
          --region "${INSTANCE_REGION}" \
          --instance-ids "${INSTANCE_ID}" \
          --document-name "AWS-RunShellScript" \
          --comment "Install Docker Compose on EC2 instance" \
          --parameters "${COMMANDS_JSON}" \
          --timeout-seconds ${TIMEOUT} \
          --query 'Command.CommandId' \
          --output text)
        
        if [ -z "$COMMAND_ID" ]; then
          echo "::error::Failed to send SSM command for Docker Compose installation"
          exit 1
        fi
        
        echo "compose-command-id=${COMMAND_ID}" >> $GITHUB_OUTPUT
        echo "command-id=${COMMAND_ID}" >> $GITHUB_OUTPUT
        echo "::notice::Docker Compose installation command sent: ${COMMAND_ID}"
        
        # Wait a few seconds for the command to be registered in SSM before polling
        echo "Waiting 5 seconds for command to be registered in SSM..."
        sleep 5
        
        # Wait for Docker Compose installation to complete
        echo "Waiting for Docker Compose installation..."
        echo "Checking SSM command status every 5 seconds..."
        MAX_WAIT=${TIMEOUT}
        ELAPSED=5  # Start at 5 since we already waited
        LAST_OUTPUT_CHECK=0
        LAST_STATUS=""
        RETRY_COUNT=0
        
        # Check if jq is available
        if ! command -v jq &> /dev/null; then
          echo "::warning::jq not found, using grep/awk for JSON parsing"
          USE_JQ=false
        else
          USE_JQ=true
        fi
        
        while [ ${ELAPSED} -lt ${MAX_WAIT} ]; do
          # Get full command invocation details with error capture
          set +e  # Temporarily disable exit on error to capture exit code
          COMMAND_INFO=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            2>&1)
          AWS_EXIT_CODE=$?
          set -e  # Re-enable exit on error
          
          # Check for errors
          if [ $AWS_EXIT_CODE -ne 0 ]; then
            STATUS="ErrorRetrievingStatus"
            RETRY_COUNT=$((RETRY_COUNT + 1))
            
            # Show the actual AWS error on first failure and every 30 seconds
            if [ $RETRY_COUNT -eq 1 ] || [ $((ELAPSED % 30)) -eq 0 ]; then
              echo "::warning::Failed to retrieve SSM command status at ${ELAPSED}s"
              echo "AWS CLI exit code: ${AWS_EXIT_CODE}"
              echo "Error output: ${COMMAND_INFO}"
              set +e
              echo "$COMMAND_INFO" | grep -q "AccessDenied\|UnauthorizedOperation" 2>/dev/null
              HAS_ACCESS_DENIED=$?
              set -e
              if [ $HAS_ACCESS_DENIED -eq 0 ]; then
                echo "::error::IAM Permission Issue: The GitHub Actions role may not have 'ssm:GetCommandInvocation' permission"
                echo "::error::Required resource ARN: arn:aws:ssm:${INSTANCE_REGION}:*:command/*"
                echo "::error::Please apply the Terraform fix in DEVOPS/modules/backend/github-oidc/main.tf"
              fi
            fi
          elif [ -z "$COMMAND_INFO" ]; then
            STATUS="ErrorRetrievingStatus"
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -eq 1 ] || [ $((ELAPSED % 30)) -eq 0 ]; then
              echo "::warning::Failed to retrieve SSM command status at ${ELAPSED}s (empty response)"
            fi
          else
            # Check if response contains error message (without causing script to exit)
            set +e
            echo "$COMMAND_INFO" | grep -q "^An error occurred" 2>/dev/null
            HAS_ERROR=$?
            set -e
            
            if [ $HAS_ERROR -eq 0 ]; then
              STATUS="ErrorRetrievingStatus"
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -eq 1 ] || [ $((ELAPSED % 30)) -eq 0 ]; then
                echo "::warning::Failed to retrieve SSM command status at ${ELAPSED}s (error in response)"
                echo "Response: ${COMMAND_INFO}"
              fi
            else
              # Parse JSON response
              set +e  # Disable exit on error for parsing
              if [ "$USE_JQ" = "true" ]; then
                STATUS=$(echo "$COMMAND_INFO" | jq -r '.Status // "Unknown"' 2>/dev/null || echo "Unknown")
                RESPONSE_CODE=$(echo "$COMMAND_INFO" | jq -r '.ResponseCode // "N/A"' 2>/dev/null || echo "N/A")
                EXECUTION_ELAPSED=$(echo "$COMMAND_INFO" | jq -r '.ExecutionElapsedTime // "N/A"' 2>/dev/null || echo "N/A")
              else
                # Fallback parsing without jq
                STATUS=$(echo "$COMMAND_INFO" | grep -o '"Status"[[:space:]]*:[[:space:]]*"[^"]*"' 2>/dev/null | cut -d'"' -f4 || echo "Unknown")
                RESPONSE_CODE=$(echo "$COMMAND_INFO" | grep -o '"ResponseCode"[[:space:]]*:[[:space:]]*[0-9]*' 2>/dev/null | cut -d':' -f2 | tr -d ' ' || echo "N/A")
                EXECUTION_ELAPSED=$(echo "$COMMAND_INFO" | grep -o '"ExecutionElapsedTime"[[:space:]]*:[[:space:]]*[0-9]*' 2>/dev/null | cut -d':' -f2 | tr -d ' ' || echo "N/A")
              fi
              set -e  # Re-enable exit on error
              RETRY_COUNT=0  # Reset retry count on successful retrieval
            fi
          fi
          
          # Show status change or progress update
          if [ "$STATUS" != "$LAST_STATUS" ] || [ $((ELAPSED % 15)) -eq 0 ]; then
            if [ "$STATUS" != "$LAST_STATUS" ]; then
              echo "::notice::SSM Command Status changed: ${LAST_STATUS:-Initial} -> ${STATUS}"
            fi
            echo "[${ELAPSED}s] Status: ${STATUS} | ResponseCode: ${RESPONSE_CODE} | SSM Execution Time: ${EXECUTION_ELAPSED}s"
            LAST_STATUS="$STATUS"
          fi
          
          if [ "$STATUS" = "Success" ]; then
            echo "::notice::Docker Compose installation completed successfully"
            break
          elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            echo "::error::Docker Compose installation failed with status: ${STATUS}"
            echo ""
            echo "=== Error Details ==="
            ERROR_OUTPUT=$(echo "$COMMAND_INFO" | jq -r '.StandardErrorContent // "No error details available"' 2>/dev/null || echo "No error details available")
            echo "Error output: ${ERROR_OUTPUT}"
            echo ""
            STDOUT=$(echo "$COMMAND_INFO" | jq -r '.StandardOutputContent // "No output available"' 2>/dev/null || echo "No output available")
            echo "Standard output: ${STDOUT}"
            echo ""
            echo "Response Code: ${RESPONSE_CODE}"
            echo "Execution Elapsed Time: ${EXECUTION_ELAPSED}s"
            echo ""
            echo "::error::Troubleshooting: Check network connectivity and GitHub releases access"
            exit 1
          fi
          
          # Retrieve and display output every 30 seconds (more frequent)
          if [ $((ELAPSED - LAST_OUTPUT_CHECK)) -ge 30 ]; then
            if [ -n "$COMMAND_INFO" ]; then
              PARTIAL_OUTPUT=$(echo "$COMMAND_INFO" | jq -r '.StandardOutputContent // ""' 2>/dev/null || echo "")
              if [ -n "$PARTIAL_OUTPUT" ] && [ "$PARTIAL_OUTPUT" != "null" ]; then
                echo ""
                echo "=== Current Installation Progress (at ${ELAPSED}s) ==="
                echo "$PARTIAL_OUTPUT"
                echo ""
              else
                echo "[${ELAPSED}s] No output available yet (command may still be starting)"
              fi
            else
              echo "[${ELAPSED}s] Unable to retrieve command information"
            fi
            LAST_OUTPUT_CHECK=${ELAPSED}
          fi
          
          sleep 5
          ELAPSED=$((ELAPSED + 5))
        done
        
        if [ "$STATUS" != "Success" ]; then
          echo "::error::Docker Compose installation timed out or failed after ${ELAPSED}s"
          echo ""
          echo "=== Final Command Status Check ==="
          FINAL_COMMAND_INFO=$(aws ssm get-command-invocation \
            --region "${INSTANCE_REGION}" \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            2>/dev/null || echo "")
          
          if [ -z "$FINAL_COMMAND_INFO" ]; then
            echo "ERROR: Unable to retrieve final command status from SSM"
            echo "This may indicate:"
            echo "  - SSM service is unavailable"
            echo "  - Command ID is invalid: ${COMMAND_ID}"
            echo "  - Instance is not accessible: ${INSTANCE_ID}"
            echo "  - IAM permissions issue"
          else
            FINAL_STATUS=$(echo "$FINAL_COMMAND_INFO" | jq -r '.Status // "Unknown"' 2>/dev/null || echo "Unknown")
            FINAL_RESPONSE_CODE=$(echo "$FINAL_COMMAND_INFO" | jq -r '.ResponseCode // "N/A"' 2>/dev/null || echo "N/A")
            FINAL_EXECUTION_TIME=$(echo "$FINAL_COMMAND_INFO" | jq -r '.ExecutionElapsedTime // "N/A"' 2>/dev/null || echo "N/A")
            FINAL_OUTPUT=$(echo "$FINAL_COMMAND_INFO" | jq -r '.StandardOutputContent // "No output available"' 2>/dev/null || echo "No output available")
            FINAL_ERROR=$(echo "$FINAL_COMMAND_INFO" | jq -r '.StandardErrorContent // "No error output available"' 2>/dev/null || echo "No error output available")
            
            echo "Status: ${FINAL_STATUS}"
            echo "Response Code: ${FINAL_RESPONSE_CODE}"
            echo "SSM Execution Time: ${FINAL_EXECUTION_TIME}s"
            echo "Polling Time: ${ELAPSED}s"
            echo ""
            echo "=== Final Output ==="
            if [ "$FINAL_OUTPUT" != "No output available" ] && [ "$FINAL_OUTPUT" != "null" ] && [ -n "$FINAL_OUTPUT" ]; then
              echo "$FINAL_OUTPUT"
            else
              echo "No output available (command may not have started or SSM is not returning output)"
            fi
            echo ""
            echo "=== Final Error Output ==="
            if [ "$FINAL_ERROR" != "No error output available" ] && [ "$FINAL_ERROR" != "null" ] && [ -n "$FINAL_ERROR" ]; then
              echo "$FINAL_ERROR"
            else
              echo "No error output available"
            fi
            echo ""
            echo "=== Full Command Details (JSON) ==="
            echo "$FINAL_COMMAND_INFO" | jq '.' 2>/dev/null || echo "$FINAL_COMMAND_INFO"
          fi
          echo ""
          echo "::error::Troubleshooting: Check network connectivity and GitHub releases access. Timeout may need to be increased for slow network connections."
          exit 1
        fi
        
        # Show Docker Compose installation output
        INSTALL_OUTPUT=$(aws ssm get-command-invocation \
          --region "${INSTANCE_REGION}" \
          --command-id "${COMMAND_ID}" \
          --instance-id "${INSTANCE_ID}" \
          --query 'StandardOutputContent' \
          --output text)
        
        echo "=== Docker Compose Installation Output ==="
        echo "$INSTALL_OUTPUT"
        echo ""
        echo "=== Installation Complete ==="
        echo "Docker and Docker Compose are ready"
