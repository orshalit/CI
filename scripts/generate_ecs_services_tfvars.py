#!/usr/bin/env python
"""
Generate Terraform 'services' blocks for the ECS Fargate layer in DEVOPS
from simple YAML specs in the CI repo.

This script is intended to be run from the CI workflow. It:
- Reads all YAML files in the given services directory.
- Produces a single services map in services.generated.tfvars for a
  specific environment / layer in the DEVOPS repo.

It intentionally focuses on attaching services to existing ALBs. ALB
definitions and Route 53 records remain managed manually in DEVOPS.
"""

import argparse
import pathlib
import textwrap

import yaml


def load_service_specs(services_dir: pathlib.Path) -> list[dict]:
    specs: list[dict] = []
    for path in sorted(services_dir.glob("*.y*ml")):
        with path.open("r", encoding="utf-8") as f:
            data = yaml.safe_load(f) or {}
        if not data.get("name"):
            raise ValueError(f"Service spec {path} is missing required 'name'")
        data["_file"] = str(path)
        specs.append(data)
    return specs


def hcl_string(value: str) -> str:
    return '"' + value.replace('"', '\\"') + '"'


def render_services_map(specs: list[dict]) -> str:
    """
    Render the Terraform 'services' map expected by the ecs-fargate module.
    
    Args:
        specs: List of service specs from CI/services/*.yaml
    """
    lines: list[str] = []
    lines.append("# Generated by CI from CI/services/*.yaml")
    lines.append("# DO NOT EDIT MANUALLY; changes will be overwritten.")
    lines.append("#")
    lines.append("# To add or modify services:")
    lines.append("# 1. Edit CI/services/*.yaml")
    lines.append("# 2. Run the 'Create / Update ECS Service' workflow in the CI repository")
    lines.append("#")
    lines.append("# Services can attach to any ALB defined in terraform.tfvars by")
    lines.append("# referencing the ALB's key in the 'alb_id' field.")
    lines.append("")
    lines.append("services = {")

    for spec in specs:
        name = spec["name"]
        image_repo = spec.get("image_repo")
        if not image_repo:
            raise ValueError(f"Service '{name}' is missing required 'image_repo'")

        container_port = int(spec.get("container_port", 80))
        cpu = int(spec.get("cpu", 256))
        memory = int(spec.get("memory", 512))
        desired_count = int(spec.get("desired_count", 1))

        env = spec.get("env", {}) or {}
        alb = spec.get("alb", {}) or {}
        autoscaling = spec.get("autoscaling") or None
        deployment = spec.get("deployment") or None

        lines.append(f"  {name} = {{")
        lines.append(f"    container_image = {hcl_string(image_repo)}")
        # The actual tag normally comes from service_image_tags at deploy time.
        lines.append(f"    image_tag       = \"latest\"")
        lines.append(f"    container_port  = {container_port}")
        lines.append(f"    cpu             = {cpu}")
        lines.append(f"    memory          = {memory}")
        lines.append(f"    desired_count   = {desired_count}")
        lines.append("")

        # Environment variables
        if env:
            lines.append("    environment_variables = {")
            for k, v in env.items():
                lines.append(f"      {k} = {hcl_string(str(v))}")
            lines.append("    }")
            lines.append("")

        # Optional ALB attachment
        if alb:
            required_alb_fields = ["alb_id", "listener_protocol", "listener_port"]
            missing = [f for f in required_alb_fields if f not in alb]
            if missing:
                raise ValueError(
                    f"Service '{name}' alb block missing required fields: {', '.join(missing)}"
                )

            lines.append("    alb = {")
            lines.append(f"      alb_id            = {hcl_string(alb['alb_id'])}")
            lines.append(
                f"      listener_protocol = {hcl_string(str(alb['listener_protocol']))}"
            )
            lines.append(f"      listener_port     = {int(alb['listener_port'])}")

            path_patterns = alb.get("path_patterns") or []
            host_patterns = alb.get("host_patterns") or []

            if path_patterns:
                rendered = ", ".join(hcl_string(p) for p in path_patterns)
                lines.append(f"      path_patterns = [{rendered}]")
            if host_patterns:
                rendered = ", ".join(hcl_string(h) for h in host_patterns)
                lines.append(f"      host_patterns = [{rendered}]")

            # Optional health check overrides
            health_check_fields = [
                "health_check_path",
                "health_check_matcher",
                "health_check_interval",
                "health_check_timeout",
                "health_check_healthy_thr",
                "health_check_unhealthy_thr",
            ]
            for field in health_check_fields:
                if field in alb:
                    value = alb[field]
                    if isinstance(value, str):
                        lines.append(f"      {field} = {hcl_string(value)}")
                    else:
                        lines.append(f"      {field} = {value}")

            lines.append("    }")
            lines.append("")

        # Optional autoscaling configuration
        if autoscaling:
            min_cap = autoscaling.get("min_capacity")
            max_cap = autoscaling.get("max_capacity")
            if min_cap is None or max_cap is None:
                raise ValueError(
                    f"Service '{name}' autoscaling block must include min_capacity and max_capacity"
                )

            lines.append("    autoscaling = {")
            lines.append(f"      min_capacity  = {int(min_cap)}")
            lines.append(f"      max_capacity  = {int(max_cap)}")
            if "cpu_target" in autoscaling:
                lines.append(f"      cpu_target    = {int(autoscaling['cpu_target'])}")
            if "memory_target" in autoscaling:
                lines.append(
                    f"      memory_target = {int(autoscaling['memory_target'])}"
                )
            lines.append("    }")
            lines.append("")

        # Optional deployment configuration
        if deployment:
            lines.append("    deployment = {")
            if "minimum_healthy_percent" in deployment:
                lines.append(f"      minimum_healthy_percent = {int(deployment['minimum_healthy_percent'])}")
            if "maximum_percent" in deployment:
                lines.append(f"      maximum_percent = {int(deployment['maximum_percent'])}")
            lines.append("    }")
            lines.append("")

        lines.append("  }")
        lines.append("")

    lines.append("}")
    lines.append("")
    return "\n".join(lines)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate ECS services.generated.tfvars for DEVOPS from CI service specs"
    )
    parser.add_argument(
        "--services-dir",
        type=pathlib.Path,
        required=True,
        help="Path to CI services spec directory (e.g. ./services)",
    )
    parser.add_argument(
        "--devops-dir",
        type=pathlib.Path,
        required=True,
        help="Path to DEVOPS repo root (as checked out in CI, e.g. ./DEVOPS)",
    )
    parser.add_argument(
        "--environment",
        type=str,
        required=True,
        help="Target environment (e.g. dev, staging, production)",
    )
    parser.add_argument(
        "--module-path",
        type=str,
        default="04-ecs-fargate",
        help="Terraform module path under live/<env> (default: 04-ecs-fargate)",
    )

    args = parser.parse_args()

    specs = load_service_specs(args.services_dir)
    if not specs:
        raise SystemExit(
            f"No service specs found in {args.services_dir}. "
            "At least one *.yaml spec is required."
        )

    ci_service_names = {spec["name"] for spec in specs}

    content = render_services_map(specs)

    target_dir = (
        args.devops_dir / "live" / args.environment / args.module_path
    )
    target_dir.mkdir(parents=True, exist_ok=True)
    target_file = target_dir / "services.generated.tfvars"

    target_file.write_text(content, encoding="utf-8")

    print(
        textwrap.dedent(
            f"""
            Wrote services map for environment '{args.environment}' to:
              {target_file}
            
            Generated {len(ci_service_names)} service(s): {', '.join(sorted(ci_service_names))}
            """
        ).strip()
    )


if __name__ == "__main__":
    main()


