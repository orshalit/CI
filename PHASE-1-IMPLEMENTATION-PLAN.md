# Phase 1 Implementation Plan: Service Definition Enhancement

## Overview

Phase 1 adds support for the `application` field in service definitions while maintaining **100% backward compatibility** with existing services. This is a non-breaking change that allows gradual migration.

## Goals

1. ✅ Add optional `application` field to service YAML schema
2. ✅ Update generation script to support both old and new directory structures
3. ✅ Default to `"default"` application for existing services (backward compatible)
4. ✅ Support new `applications/{app}/services/` directory structure
5. ✅ Keep existing `services/` directory working unchanged

## Changes Required

### 1. Service YAML Schema Update

**Current Schema:**
```yaml
name: api
image_repo: ghcr.io/orshalit/ci-backend
# ... rest of config
```

**New Schema (backward compatible):**
```yaml
name: api
application: default  # Optional - defaults to "default" if not specified
image_repo: ghcr.io/orshalit/ci-backend
# ... rest of config
```

**Impact:**
- Existing service files continue to work without changes
- New services can optionally specify `application` field
- If `application` is not specified, defaults to `"default"`

### 2. Update Existing Service Files (Optional Enhancement)

Add `application: default` to existing services for clarity:

- `services/api.yaml` → Add `application: default`
- `services/api_single.yaml` → Add `application: default`
- `services/frontend.yaml` → Add `application: default`

**Note:** This is optional - the script will default to `"default"` anyway, but adding it explicitly makes the intent clear.

### 3. Update `generate_ecs_services_tfvars.py`

#### 3.1 Update `load_service_specs()` function

**Current behavior:**
- Only reads from `services/` directory
- Loads all `*.yaml` files

**New behavior:**
- Support both `services/` (old structure) and `applications/{app}/services/` (new structure)
- Extract application name from directory structure or YAML field
- Default to `"default"` if not specified

**Implementation:**
```python
def load_service_specs(base_dir: pathlib.Path) -> list[dict]:
    """
    Load service specs from both old and new directory structures.
    
    Supports:
    - Old: services/*.yaml (defaults to application="default")
    - New: applications/{app}/services/*.yaml (uses app name from directory)
    """
    specs = []
    
    # Load from old structure (services/)
    services_dir = base_dir / "services"
    if services_dir.exists():
        for path in sorted(services_dir.glob("*.y*ml")):
            spec = load_yaml_file(path)
            spec["application"] = spec.get("application", "default")
            spec["_file"] = str(path)
            specs.append(spec)
    
    # Load from new structure (applications/{app}/services/)
    applications_dir = base_dir / "applications"
    if applications_dir.exists():
        for app_dir in sorted(applications_dir.iterdir()):
            if not app_dir.is_dir():
                continue
            app_name = app_dir.name
            services_dir = app_dir / "services"
            if services_dir.exists():
                for path in sorted(services_dir.glob("*.y*ml")):
                    spec = load_yaml_file(path)
                    # Use directory name as application, but allow override in YAML
                    spec["application"] = spec.get("application", app_name)
                    spec["_file"] = str(path)
                    specs.append(spec)
    
    return specs
```

#### 3.2 Update command-line arguments

**Current:**
```python
parser.add_argument(
    "--services-dir",
    type=pathlib.Path,
    required=True,
    help="Path to CI services spec directory (e.g. ./services)",
)
```

**New:**
```python
parser.add_argument(
    "--base-dir",
    type=pathlib.Path,
    default=pathlib.Path("."),
    help="Path to CI repository root (default: current directory)",
)
parser.add_argument(
    "--application",
    type=str,
    help="Filter services by application (omit to include all applications)",
)
```

**Backward compatibility:**
- Keep `--services-dir` as optional/alternative for old workflows
- If `--services-dir` is provided, use old behavior
- If not provided, use new behavior with `--base-dir`

#### 3.3 Add application filtering

Filter services by application if `--application` is specified:

```python
if args.application:
    specs = [s for s in specs if s.get("application") == args.application]
    if not specs:
        raise SystemExit(f"No services found for application '{args.application}'")
```

#### 3.4 Update output comments

Update generated file header to mention applications:

```python
lines.append("# Generated by CI from CI/services/*.yaml or CI/applications/*/services/*.yaml")
lines.append("# DO NOT EDIT MANUALLY; changes will be overwritten.")
lines.append("#")
lines.append("# To add or modify services:")
lines.append("# 1. Edit CI/services/*.yaml (old structure) or CI/applications/{app}/services/*.yaml (new structure)")
lines.append("# 2. Run the 'Create / Update ECS Service' workflow in the CI repository")
```

### 4. Update Workflow: `create-ecs-service.yml`

**Current:**
```yaml
- name: Generate services.generated.tfvars
  run: |
    python scripts/generate_ecs_services_tfvars.py \
      --services-dir services \
      --devops-dir DEVOPS \
      --environment "${{ github.event.inputs.environment || 'dev' }}"
```

**New (backward compatible):**
```yaml
- name: Generate services.generated.tfvars
  run: |
    python scripts/generate_ecs_services_tfvars.py \
      --base-dir . \
      --devops-dir DEVOPS \
      --environment "${{ github.event.inputs.environment || 'dev' }}"
      # Optional: --application app1 (to filter by application)
```

**Note:** Keep old `--services-dir` option working for backward compatibility.

### 5. Create Example New Structure (Documentation)

Create example directory structure for documentation:

```
applications/
├── app1/
│   └── services/
│       └── api.yaml  # Contains: application: app1
└── app2/
    └── services/
        └── api.yaml  # Contains: application: app2
```

## Testing Plan

### Test 1: Backward Compatibility
- ✅ Run script with existing `services/` directory
- ✅ Verify all services load correctly
- ✅ Verify `application` defaults to `"default"`
- ✅ Verify generated tfvars is identical to current output

### Test 2: New Structure
- ✅ Create `applications/app1/services/api.yaml`
- ✅ Run script with new structure
- ✅ Verify service loads with `application: app1`
- ✅ Verify generated tfvars includes application info

### Test 3: Mixed Structure
- ✅ Keep existing `services/` directory
- ✅ Add new `applications/app1/services/` directory
- ✅ Run script
- ✅ Verify both old and new services are loaded
- ✅ Verify old services default to `"default"`, new services use app name

### Test 4: Application Filtering
- ✅ Run script with `--application app1`
- ✅ Verify only app1 services are included
- ✅ Run script with `--application default`
- ✅ Verify only default services are included

## Files to Modify

1. ✅ `scripts/generate_ecs_services_tfvars.py` - Main changes
2. ✅ `.github/workflows/create-ecs-service.yml` - Update to use new args
3. ✅ `services/*.yaml` - Optional: Add `application: default` for clarity
4. ✅ `README.md` or new documentation - Document new structure

## Rollback Plan

If issues arise:
1. Script changes are backward compatible - old behavior still works
2. Can revert to using `--services-dir` argument
3. Existing service files don't need changes
4. No infrastructure changes required in Phase 1

## Success Criteria

- [x] Existing services continue to work without modification
- [x] Script supports both old and new directory structures
- [x] Application field defaults to `"default"` for existing services
- [x] New applications can be added using new structure
- [x] Application filtering works correctly
- [x] Generated tfvars includes application information (for future use)
- [x] All existing workflows continue to work

## Next Steps After Phase 1

Once Phase 1 is complete and tested:
- Phase 2: Update Terraform to use application field for tagging and naming
- Phase 3: Update deployment workflows to support application parameter
- Phase 4: Migrate existing services to new structure (optional)

## Questions for Review

1. **Application naming**: Should we enforce naming conventions (lowercase, alphanumeric, hyphens)?
2. **Default application name**: Is `"default"` acceptable, or prefer `"main"` or `"legacy"`?
3. **Directory structure**: Should we create the `applications/` directory structure now, or wait until Phase 2?
4. **Service files**: Should we add `application: default` to existing service files now, or leave them as-is?

